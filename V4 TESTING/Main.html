<!-- MODIFICATIONS TO THIS TOOL WILL RESULT IN YOU LOSING ACCESS IF CAUGHT -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="./important/favicon.png" type="image/x-icon">
    <title>Blake's Encryptor/Decryptor V4 Testing Build</title>
    <link href="https://fonts.googleapis.com/css2?family=Signika+Negative:wght@400;700&family=Sedgwick+Ave+Display&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./js/styles.css">
    <!-- App version for VersionCheck.js to read -->
    <meta name="app-version" content="4.0.0">
</head>
<body>
    <!-- Version banner placeholder (optional) -->
    <div id="versionBannerContainer"></div>

    <div id="access-denied" style="display: none;">
        <!-- dynamically set in code -->
    </div>

    <div id="special-access-denied" style="display: none;">
        <!-- dynamically set in code -->
    </div>

    <div class="container" style="display: none;">
        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-value" id="encryptedCount">0</div>
                <div class="stat-label">Messages Encrypted</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="decryptedCount">0</div>
                <div class="stat-label">Messages Decrypted</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="activeCount">0</div>
                <div class="stat-label">Active Messages</div>
            </div>
        </div>
        <div class="header">
            <h1>
                Blake's Encryptor/Decryptor V4 Testing Build
            </h1>
        </div>

        <div id="alertContainer"></div>

        <div class="form-group">
            <label for="password">Password</label>
            <div class="input-group">
                <input type="password" id="password" placeholder="Enter your password" required>
                <button class="password-toggle" onclick="togglePassword()" aria-label="Toggle password visibility">👁️</button>
            </div>
        </div>

        <div class="form-group">
            <label for="inputText">Message</label>
            <textarea id="inputText" placeholder="Enter your message here or upload a file" required></textarea>
        </div>


        <div class="form-group">
            <input type="file" id="fileInput" class="file-input" accept="text/plain">
            <label for="fileInput" class="file-label">📎 Upload Text File</label>
        </div>

        

        <div class="self-destruct-container">
            <div class="self-destruct-header">
                <label for="selfDestructTime">Self-Destruct Time (Optional)</label>
                <button type="button" class="toggle-quick-set" aria-expanded="false" aria-controls="quickSetOptions">
                    Quick Set Options
                </button>
            </div>
            <div class="self-destruct-input-group">
                <input type="datetime-local" id="selfDestructTime" aria-describedby="selfDestructDesc">
                <p id="selfDestructDesc" class="sr-only">Set a date and time for the message to self-destruct, or use the quick-set options below.</p>
            </div>
            <div id="quickSetOptions" class="quick-set-options" role="region" aria-labelledby="quickSetHeading" hidden>
                <h3 id="quickSetHeading" class="sr-only">Quick Set Options</h3>
                <div class="quick-set-buttons">
                    <button type="button" class="quick-set" data-minutes="10">+10 Minutes</button>
                    <button type="button" class="quick-set" data-minutes="30">+30 Minutes</button>
                    <button type="button" class="quick-set" data-minutes="60">+1 Hour</button>
                    <button type="button" class="quick-set" data-minutes="180">+3 Hours</button>
                    <button type="button" class="quick-set today-btn" data-today="3pm">Today 3PM</button>
                </div>
            </div>
        </div>

    <!-- Auto Self-Destruct Modal -->
        <div class="modal-overlay" id="autoSelfDestructOverlay" onclick="closeAutoSelfDestruct()"></div>
        <div class="modal" id="autoSelfDestructModal">
            <div class="modal-header">
                <h2>Auto Self-Destruct Settings</h2>
                <button class="modal-close" onclick="closeAutoSelfDestruct()">×</button>
            </div>
            <div class="modal-body">
                <form id="autoSelfDestructForm" onsubmit="saveAutoSelfDestruct(event)">
                    <div class="form-group">
                        <label>Enable Auto Self-Destruct</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="autoSelfDestructToggle" onchange="toggleAutoSelfDestruct()">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    <div class="form-group" id="timeInputGroup">
                        <label for="autoSelfDestructTime">Set Default Expiry Time</label>
                        <input type="time" id="autoSelfDestructTime" name="autoSelfDestructTime" required>
                        <p class="time-note">Note: Messages will expire at this time daily. If the time has passed, it will be set for tomorrow.</p>
                    </div>
                    <button type="submit" class="btn btn-primary">Save Settings</button>
                </form>
            </div>
        </div>

        <div class="button-group">
            <button id="encryptBtn" class="button" onclick="onEncryptClick()">🔒 Encrypt</button>
            <button id="decryptBtn" class="button" onclick="onDecryptClick()">🔓 Decrypt</button>
            <button class="button btn-danger" onclick="clearAll()">🗑️ Clear All</button>
        </div>

        <div class="result-container">
            <div class="input-group">
                <textarea id="resultText" readonly></textarea>
                <div class="time-remaining" id="timeRemaining"></div>
            </div>
            <div id="selfDestructIndicator" class="self-destruct-indicator"></div>
        </div>

        <div class="button-group">
            <button class="button" onclick="copyResult()">📋 Copy</button>
            <button class="button" onclick="downloadResult()">💾 Save</button>
        </div>
    </div>

<!-- Settings Button -->
<button id="settingsBtn" class="settings-button" onclick="toggleSettings()" aria-label="Open settings" aria-haspopup="dialog" aria-expanded="false">
    <span class="settings-icon">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" style="position: fixed; left: -1.5px; bottom: -3px;">
            <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V22a2 2 0 0 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H2a2 2 0 0 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h.09a1.65 1.65 0 0 0 1-1.51V2a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l-.06-.06a2 2 0 0 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82v.09a1.65 1.65 0 0 0 1.51 1H22a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/>
        </svg>
    </span>
</button>

<!-- Redesigned Settings Panel -->
<div class="settings-overlay" id="settingsOverlay" aria-hidden="true" onclick="toggleSettings(event)">
    <div class="settings-panel" id="settingsPanel" data-variant="drawer" role="dialog" aria-modal="true" aria-labelledby="settingsTitle" onclick="stopPropagation(event)" tabindex="-1">
        <div class="settings-header">
            <div>
                <h3 id="settingsTitle">Settings • <span id="settingsUsername" class="username-loading">Loading...</span></h3>
                <p class="settings-subtitle">Configure appearance, features, and behavior.</p>
            </div>
            <button class="settings-close" onclick="toggleSettings()" aria-label="Close settings" title="Close">×</button>
        </div>
        
        <div class="settings-content">
            <div class="settings-tabs-container">
                <div class="settings-tabs" role="tablist" aria-label="Settings Tabs">
                    <button id="tab-general-btn" class="settings-tab" role="tab" aria-selected="true" data-tab="general">✨ General</button>
                    <button id="tab-features-btn" class="settings-tab" role="tab" aria-selected="false" data-tab="features">🧩 Features</button>
                    <button id="tab-about-btn" class="settings-tab" role="tab" aria-selected="false" data-tab="about">ℹ️ About</button>
                </div>
            </div>

            <div class="settings-quick-actions">
                <button class="settings-btn" onclick="openHistory()">History</button>
                <button class="settings-btn" onclick="reportBug()">Report Bug</button>
                <button class="settings-btn" onclick="(function(){try{VersionCheck.setDebug(true);}catch(_){} try{VersionCheck.compareAndNotify();}catch(e){console.warn('[VersionCheck] check failed:', e);}})()">Check Version</button>
                <button class="settings-btn btn-danger" onclick="resetAllData()">Reset</button>
            </div>

            <div class="settings-sections">
                <section id="tab-general" class="settings-section" role="tabpanel" aria-labelledby="tab-general-btn">
                    <div class="settings-list">
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Dark Mode</span>
                                <small class="setting-desc">Switch between light and dark themes.</small>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="themeToggle" onchange="toggleTheme()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Auto-Copy Result</span>
                                <small class="setting-desc">Automatically copy output after encrypt/decrypt.</small>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="autoCopy" onchange="localStorage.setItem('autoCopy', this.checked);">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Password Protection</span>
                                <small class="setting-desc">Secure your messages with a password</small>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="enablePasswordProtection" onchange="togglePasswordProtection()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div id="passwordSettings" style="display: none; margin-left: 20px; border-left: 2px solid var(--border-color); padding-left: 15px; margin-top: 10px;">
                            <div class="setting-item">
                                <div class="setting-text">
                                    <span class="setting-title">Auto-lock after inactivity</span>
                                    <small class="setting-desc">Lock after 15 minutes of inactivity</small>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="autoLock" checked>
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                            <div class="setting-item">
                                <div class="setting-text">
                                    <span class="setting-title">Change Password</span>
                                    <small class="setting-desc">Set a new password for your application</small>
                                </div>
                                <button class="settings-btn" onclick="showPasswordChangeModal()" style="padding: 6px 12px;">Change Password</button>
                            </div>
                            <div class="password-strength-meter" style="margin-top: 10px; display: none;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                                    <small>Password Strength:</small>
                                    <small id="passwordStrengthText">Weak</small>
                                </div>
                                <div style="height: 4px; background: var(--border-color); border-radius: 2px; overflow: hidden;">
                                    <div id="passwordStrengthBar" style="height: 100%; width: 0%; background: #ff4444; transition: width 0.3s, background 0.3s;"></div>
                                </div>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Accent Color</span>
                                <small class="setting-desc">Customize the app accent color.</small>
                            </div>
                            <input type="color" id="accentColorPicker" aria-label="Choose accent color" onchange="setAccentColor(this.value)">
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Compact Mode</span>
                                <small class="setting-desc">Reduce paddings for denser layout.</small>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="compactModeToggle" onchange="toggleCompactMode()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Reduce Motion</span>
                                <small class="setting-desc">Disable most animations and transitions.</small>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="reduceMotionToggle" onchange="toggleReduceMotion()">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Require Password</span>
                                <small class="setting-desc">Enable password protection and require a password to unlock the app.</small>
                            </div>
                            <label class="toggle-switch">
                                <input type="checkbox" id="enablePasswordProtection">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div id="passwordSettings" style="display:none">
                            <div class="setting-item">
                                <div class="setting-text">
                                    <span class="setting-title">Auto-Lock</span>
                                    <small class="setting-desc">Automatically lock after inactivity.</small>
                                </div>
                                <label class="toggle-switch">
                                    <input type="checkbox" id="autoLock">
                                    <span class="toggle-slider"></span>
                                </label>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Session Lock</span>
                                <small class="setting-desc">Lock the application with a password</small>
                            </div>
                            <button class="settings-btn" onclick="setupSessionLock()">Set Lock Password</button>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Report a Bug</span>
                                <small class="setting-desc">Found an issue? Send a quick report.</small>
                            </div>
                            <button class="settings-btn" onclick="reportBug()">Report Bug</button>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Keyboard Shortcuts</span>
                                <small class="setting-desc">Customize hotkeys for frequent actions.</small>
                            </div>
                            <button class="settings-btn" onclick="openShortcutSettings()">Configure</button>
                        </div>
                    </div>
                </section>
                <section id="tab-features" class="settings-section" role="tabpanel" aria-labelledby="tab-features-btn" hidden>
                    <div class="settings-list">
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Auto Self-Destruct</span>
                                <small class="setting-desc">Set a daily default expiry for new messages.</small>
                            </div>
                            <button class="settings-btn" onclick="openAutoSelfDestruct()">Configure</button>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Message History</span>
                                <small class="setting-desc">Review or clear your previous messages.</small>
                            </div>
                            <button class="settings-btn" onclick="openHistory()">View</button>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Reset All Data</span>
                                <small class="setting-desc">Wipes preferences, history, and stats.</small>
                            </div>
                            <button class="settings-btn btn-danger" onclick="resetAllData()">Reset</button>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Export Settings</span>
                                <small class="setting-desc">Download your preferences as JSON.</small>
                            </div>
                            <button class="settings-btn" onclick="exportSettings()">Export</button>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Import Settings</span>
                                <small class="setting-desc">Load preferences from a JSON file.</small>
                            </div>
                            <div>
                                <input id="importSettingsInput" type="file" accept="application/json" style="display:none" onchange="handleImportSettings(event)">
                                <button class="settings-btn" onclick="document.getElementById('importSettingsInput').click()">Import</button>
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Backup Message History</span>
                                <small class="setting-desc">Download your message history as JSON.</small>
                            </div>
                            <button class="settings-btn" onclick="backupHistory()">Backup</button>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Clear Cache</span>
                                <small class="setting-desc">Clear non-essential cached data.</small>
                            </div>
                            <button class="settings-btn btn-danger" onclick="clearCache()">Clear</button>
                        </div>
                    </div>
                </section>
                <section id="tab-about" class="settings-section" role="tabpanel" aria-labelledby="tab-about-btn" hidden>
                <!-- adds a little space between the two -->
                    <div class="settings-list">
                        <div class="setting-item no-hover" style="justify-content: center; pointer-events: none;">
                            <span style="user-select: none; pointer-events: none;">Version V4.0.0</span>
                        </div>
                        <div class="setting-item">
                            <div class="setting-text">
                                <span class="setting-title">Updates</span>
                                <small class="setting-desc">Check the server for a newer version and show a banner if available.</small>
                            </div>
                            <button class="settings-btn" onclick="(function(){try{VersionCheck.setDebug(true);}catch(_){} try{VersionCheck.compareAndNotify();}catch(e){console.warn('[VersionCheck] check failed:', e);}})()">Check for Updates</button>
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="setting-text">
                            <span class="setting-title">Report Bug</span>
                            <small class="setting-desc">Found a glitch? Help improve by reporting.</small>
                        </div>
                        <button class="settings-btn" onclick="reportBug()">Report Issue</button>
                    </div>
                </section>
            </div>
        </div>
    </div>
</div>


<!-- Page Layout Settings Modal (SCRAPPED) -->
<div class="modal-overlay" id="pageLayoutOverlay" onclick="closePageLayoutSettings()"></div>
<div class="modal" id="pageLayoutModal">
    <div class="modal-header">
        <h2>Page Layout Settings</h2>
        <button class="modal-close" onclick="closePageLayoutSettings()">×</button>
        <p>Hello anyone who reads this through the source code, Uhhhhhh this was never finished and you can't even open this page unless you open it through the console....</p>
    </div>
</div>

<!-- Updated History Modal -->
<div class="modal-overlay" id="historyOverlay" onclick="closeHistory()"></div>
<div class="modal" id="historyModal">
    <div class="modal-header">
        <h2>Message History</h2>
        <button class="modal-close" onclick="closeHistory()">×</button>
    </div>
    <div class="modal-body">
        <div id="historyList" class="settings-list"></div>
        <button class="btn btn-danger history-btn" onclick="clearHistory()">Clear History</button>
    </div>
</div>

    

        <!-- Shortcut Settings Modal -->
    <div class="modal-overlay" id="shortcutOverlay" onclick="closeShortcutSettings()"></div>
    <div class="modal" id="shortcutModal">
        <div class="modal-header">
            <h2>Keyboard Shortcuts</h2>
            <button class="modal-close" onclick="closeShortcutSettings()">×</button>
        </div>
        <div class="modal-body">
            <form id="shortcutForm" onsubmit="saveShortcutSettings(event)">
                <div class="form-group" id="shortcutSettings">
                    <!-- Shortcuts will be dynamically populated -->
                </div>
                <button type="submit" class="btn btn-primary">Save Settings</button>
                <button type="button" class="btn btn-secondary" onclick="resetShortcuts()">Reset to Default</button>
            </form>
        </div>
    </div>

    <!-- Session Lock Screen -->
    <div id="lockScreen" class="lock-screen" style="display: none;">
        <div class="lock-screen-content">
            <div class="sentry-lock">
                <div class="sentry-text">SENTRYLOCK</div>
            </div>
            <div class="lock-form">
                <input type="password" id="lockPassword" class="lock-password" placeholder="Enter password to unlock" autocomplete="current-password">
                <button onclick="unlockSession(event)" class="btn btn-primary">Unlock</button>
            </div>
        </div>
    </div>

    <script src="./js/Whitelist.js"></script>
    <!-- <script src="./js/Console.js"></script> -->
    <script src="./js/config.js"></script>
    <script src="./js/MessageService.js"></script>
    <script src="./js/BugReport.js"></script>  
    <script src="./js/messageHistory.js"></script>
    <script src="./js/Settings.js"></script>

    <!-- Bug Report Modal -->
    <div id="bugReportOverlay" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="bugReportTitle">
      <div id="bugReportModal" class="modal" onclick="event.stopPropagation()">
        <div class="modal-header">
          <h3 id="bugReportTitle">Report a Bug</h3>
          <button class="modal-close" onclick="closeBugReport()" aria-label="Close">×</button>
        </div>
        <div class="modal-content">
          <form id="bugReportForm" onsubmit="submitBugReport(event)">
            <div class="tips-callout" role="note" aria-label="Reporting tips">
              <div class="tips-title">Tips for a helpful report</div>
              <ul class="tips-list">
                <li><strong>Steps:</strong> How to reproduce it, step-by-step.</li>
                <li><strong>Expected:</strong> What you thought would happen.</li>
                <li><strong>Actual:</strong> What actually happened (errors, screenshots).</li>
                <li><strong>Context:</strong> Where you were in the app and what you clicked.</li>
              </ul>
              <button type="button" id="bugTemplateBtn" class="btn btn-secondary small">Insert Template</button>
            </div>
            <div class="form-group">
              <div class="label-row">
                <label for="bugTitle">Issue Title</label>
                <small id="bugTitleCount" class="char-counter">0/80</small>
              </div>
              <input type="text" id="bugTitle" name="bugTitle" placeholder="e.g., Encryption fails on large files" required>
            </div>

            <!-- Custom dropdown for Type (hidden select used as form value holder) -->
            <div class="form-group">
              <label for="bugTypeButton">Issue Type</label>
              <input type="hidden" id="bugType" name="bugType" value="ui">
              <button id="bugTypeButton" class="dropdown-btn" type="button" aria-haspopup="listbox" aria-expanded="false">
                <span class="label">UI</span>
                <span class="chevron">▾</span>
              </button>
              <div id="bugTypeMenu" class="dropdown-menu" role="listbox" data-open="false">
                <button role="option" class="dropdown-item" data-value="ui">UI</button>
                <button role="option" class="dropdown-item" data-value="performance">Performance</button>
                <button role="option" class="dropdown-item" data-value="security">Security</button>
                <button role="option" class="dropdown-item" data-value="other">Other</button>
              </div>
            </div>

            <div class="form-group">
              <div class="label-row">
                <label for="bugDescription">Description</label>
                <small id="bugDescriptionCount" class="char-counter">0/1000</small>
              </div>
              <textarea id="bugDescription" name="bugDescription" rows="6" placeholder="Describe the issue clearly, steps to reproduce, expected vs actual, errors." required></textarea>
            </div>
            <div class="form-actions">
              <button type="submit" class="btn btn-primary">Submit</button>
              <button type="button" class="btn btn-secondary" onclick="closeBugReport()">Cancel</button>
            </div>
          </form>
        </div>
      </div>
    </div>
    <script src="./js/Encrypt.js"></script>
    <script src="./js/Decrypt.js"></script>
    <script>
      window.__APP_VERSION__ = '4.0.0';
    </script>
    <script src="./js/VersionCheck.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        if (window.VersionCheck && typeof VersionCheck.compareAndNotify === 'function') {
          VersionCheck.compareAndNotify();
        }
      });
    </script>

<script>

function toggleSection(sectionId) {
    const section = document.getElementById(sectionId);
    const header = section.previousElementSibling;
    const isActive = header.classList.toggle('active');

    if (isActive) {
        section.style.display = 'block';
        header.querySelector('.arrow').textContent = '▲';
    } else {
        section.style.display = 'none';
        header.querySelector('.arrow').textContent = '▼';
    }
}

// Password protection state
let isPasswordRequired = false;
let passwordInput = null;
let passwordGroup = null;
let failedAttempts = 0;
const PASSWORD_MAX_ATTEMPTS = 5;
const PASSWORD_LOCKOUT_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds
let passwordLockoutEndTime = 0;

// Function to set password requirement
function setPasswordRequired(required) {
    // Update the global state
    isPasswordRequired = required;
    
    // Save to localStorage
    localStorage.setItem('requirePassword', required);
    
    // Update the UI
    updatePasswordField();
    
    // If enabling password requirement, validate the current password
    if (required) {
        const passwordInput = document.getElementById('password');
        if (passwordInput && passwordInput.value) {
            const { isValid, message } = validatePassword(passwordInput.value, true);
            if (!isValid) {
                showAlert(message, 'error');
                passwordInput.focus();
                return false;
            }
        }
    }
    
    // Update the toggle if it exists
    const requirePasswordToggle = document.getElementById('requirePassword');
    if (requirePasswordToggle) {
        requirePasswordToggle.checked = required;
    }
    
    return true;
}

// Initialize password elements when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Initialize and verify all settings in localStorage first
    localStorageCheck();
    
    passwordInput = document.getElementById('password');
    passwordGroup = document.querySelector('.form-group');
    
    // Initialize password requirement toggle
    const savedRequirePassword = localStorage.getItem('requirePassword') === 'true';
    
    // Initialize auto-copy toggle
    const autoCopyToggle = document.getElementById('autoCopy');
    if (autoCopyToggle) {
        autoCopyToggle.checked = localStorage.getItem('autoCopy') === 'true';
    }
    const requirePasswordToggle = document.getElementById('requirePassword');
    
    if (requirePasswordToggle) {
        requirePasswordToggle.checked = savedRequirePassword;
        setPasswordRequired(savedRequirePassword);
        
        requirePasswordToggle.addEventListener('change', function() {
            setPasswordRequired(this.checked);
        });
    }
});

// Function to ensure all settings are properly initialized and saved to localStorage
function localStorageCheck() {
    // Define default settings with proper types (strings for localStorage)
    const defaultSettings = {
        'theme': 'light',
        'autoCopy': 'false',
        'accentColor': '#4a6bff',
        'compactMode': 'false',
        'reduceMotion': 'false',
        'shortcutsEnabled': 'true',
        'requirePassword': 'false',
        'lastActiveTab': 'general',
        'autoSelfDestructEnabled': 'false',
        'autoSelfDestructTime': '23:59'
    };

    // Check and initialize each setting
    Object.entries(defaultSettings).forEach(([key, defaultValue]) => {
        try {
            if (localStorage.getItem(key) === null) {
                localStorage.setItem(key, defaultValue);
            }
        } catch (e) {
            console.error(`Failed to initialize setting ${key}:`, e);
        }
    });

    // Special handling for complex objects
    const complexSettings = {
        'keyboardShortcuts': {},
        'passwordSettings': {},
        'accessAttempts': '[]',
        'messageHistory': '[]',
        'manuallyExpiredIds': '[]',
        'sentryBlacklist': '[]'
    };

    Object.entries(complexSettings).forEach(([key, defaultValue]) => {
        try {
            if (localStorage.getItem(key) === null) {
                localStorage.setItem(key, typeof defaultValue === 'string' ? defaultValue : JSON.stringify(defaultValue));
            }
        } catch (e) {
            console.error(`Failed to initialize complex setting ${key}:`, e);
        }
    });

    // Verify and repair corrupted JSON data
    const jsonSettings = ['keyboardShortcuts', 'passwordSettings', 'accessAttempts', 'messageHistory', 'manuallyExpiredIds', 'sentryBlacklist'];
    jsonSettings.forEach(key => {
        try {
            const value = localStorage.getItem(key);
            if (value) {
                JSON.parse(value); // Will throw if invalid JSON
            }
        } catch (e) {
            console.warn(`Repairing corrupted ${key} setting`);
            localStorage.setItem(key, complexSettings[key] || '{}');
        }
    });
}

function updatePasswordField() {
    if (!passwordInput || !passwordGroup) return;
    
    if (isPasswordRequired) {
        passwordInput.required = true;
        passwordInput.placeholder = 'Password required';
        passwordInput.style.borderColor = '#ff4444';
    } else {
        passwordInput.required = false;
        passwordInput.placeholder = 'Password (optional)';
        passwordInput.style.borderColor = '';
    }
}

/**
 * Validates a password against security requirements
 * @param {string} password - The password to validate
 * @param {boolean} [enforceRequirement=true] - Whether to enforce password requirement
 * @returns {{isValid: boolean, message: string}} Validation result
 */
function validatePassword(password, enforceRequirement = true) {
    // If password is not required and empty, it's valid
    if (!isPasswordRequired && (!password || !password.trim())) {
        return { isValid: true, message: '' };
    }

    // If password is required but empty
    if (enforceRequirement && isPasswordRequired && (!password || !password.trim())) {
        return { 
            isValid: false, 
            message: 'Password is required when password protection is enabled' 
        };
    }

    // Check minimum length (only if password is provided)
    if (password && password.length < 8) {
        return { 
            isValid: false, 
            message: 'Password must be at least 8 characters long' 
        };
    }

    // Check maximum length
    if (password && password.length > 100) {
        return { 
            isValid: false, 
            message: 'Password cannot exceed 100 characters' 
        };
    }

    return { isValid: true, message: '' };
}

/**
 * Validates the password input field and shows appropriate feedback
 * @returns {boolean} True if password is valid, false otherwise
 */
function validatePasswordInput() {
    const passwordInput = document.getElementById('password');
    if (!passwordInput) {
        showAlert('Password field not found', 'error');
        return false;
    }
    
    // Check if account is locked out
    const now = Date.now();
    if (passwordLockoutEndTime > now) {
        const minutesLeft = Math.ceil((passwordLockoutEndTime - now) / 60000);
        showAlert(`Too many failed attempts. Please try again in ${minutesLeft} minute${minutesLeft === 1 ? '' : 's'}.`, 'error');
        return false;
    }

    const password = passwordInput.value;
    const { isValid, message } = validatePassword(password, true);
    
    if (!isValid) {
        failedAttempts++;
        
        // Check if we should lock the account
        if (failedAttempts >= PASSWORD_MAX_ATTEMPTS) {
            passwordLockoutEndTime = now + PASSWORD_LOCKOUT_DURATION;
            const minutes = PASSWORD_LOCKOUT_DURATION / 60000;
            showAlert(`Too many failed attempts. Account locked for ${minutes} minutes.`, 'error');
            // Disable the input field during lockout
            passwordInput.disabled = true;
            setTimeout(() => {
                passwordInput.disabled = false;
                failedAttempts = 0;
                passwordLockoutEndTime = 0;
            }, PASSWORD_LOCKOUT_DURATION);
        } else {
            const remainingAttempts = PASSWORD_MAX_ATTEMPTS - failedAttempts;
            showAlert(`${message} (${remainingAttempts} attempt${remainingAttempts === 1 ? '' : 's'} remaining)`, 'error');
        }
        
        passwordInput.focus();
        return false;
    }
    
    // Reset failed attempts on successful validation
    failedAttempts = 0;
    return true;
}

function ensureMessageServiceReady(actionLabel) {
    try {
        if (!window.MessageService) {
            if (typeof sentryLockMS === 'function') {
                sentryLockMS('MessageService Missing', { hint: 'Reload the page or set localStorage.messageServiceEndpoint to your /macros/s/.../exec URL' });
            } else {
                alert('MessageService is missing. Please reload and configure endpoint.');
            }
            return false;
        }
        const endpoint = localStorage.getItem('messageServiceEndpoint') || '';
        if (!endpoint) {
            if (typeof sentryLockMS === 'function') {
                sentryLockMS('Missing Endpoint', { hint: 'Set localStorage.messageServiceEndpoint to your deployed Apps Script Web App URL' });
            } else {
                alert('Endpoint missing. Set localStorage.messageServiceEndpoint to your Web App URL.');
            }
            return false;
        }
        return true;
    } catch (e) {
        console.error('ensureMessageServiceReady error:', e);
        return false;
    }
}

async function onEncryptClick() {
    try {
        // First validate the password if required
        if (isPasswordRequired && !validatePasswordInput()) {
            return;
        }
        
        // Then proceed with encryption
        const success = await encryptMessage();
        if (success && window.MessageService && MessageService.createMessage && window.lastMessageMeta) {
            const endpoint = localStorage.getItem('messageServiceEndpoint') || 'https://script.google.com/macros/s/AKfycbyNFNmKjtMrzh7wQMDF81jPE_6JuA9LEYRIYeoYCGETkOstm0OWZYSPptv4MmU6JoXN_Q/exec';
            if (endpoint) {
                MessageService.createMessage(window.lastMessageMeta);
            } else if (typeof sentryLockMS === 'function') {
                sentryLockMS('Missing Endpoint', { hint: 'Set localStorage.messageServiceEndpoint to your deployed Apps Script Web App URL' });
            }
        }
    } catch (e) {
        console.error('onEncryptClick error:', e);
        showAlert('An error occurred during encryption. Please try again.', 'error');
    }
}

async function onDecryptClick() {
    try {
        // First validate the password if required
        if (isPasswordRequired && !validatePasswordInput()) {
            return;
        }
        
        // Then proceed with decryption
        const success = await decryptMessage();
        if (success && window.MessageService && MessageService.incrementDecryptionCount && window.lastDecryptedId) {
            const endpoint = localStorage.getItem('messageServiceEndpoint') || 'https://script.google.com/macros/s/AKfycbyNFNmKjtMrzh7wQMDF81jPE_6JuA9LEYRIYeoYCGETkOstm0OWZYSPptv4MmU6JoXN_Q/exec';
            if (endpoint) {
                MessageService.incrementDecryptionCount(window.lastDecryptedId);
            } else if (typeof sentryLockMS === 'function') {
                sentryLockMS('Missing Endpoint', { hint: 'Set localStorage.messageServiceEndpoint to your deployed Apps Script Web App URL' });
            }
        }
    } catch (e) {
        console.error('Error in onDecryptClick:', e);
        showAlert('An error occurred while decrypting. Please try again.', 'error');
    }
}



                // Disable scrolling when bug report modal is open
                const bugReportModal = document.getElementById('bugReportModal');
        bugReportModal.addEventListener('show', () => {
            document.body.style.overflow = 'hidden';
        });
        bugReportModal.addEventListener('hide', () => {
            document.body.style.overflow = null;
        });

// Rate limiter
const MAX_ATTEMPTS = 5;
const ATTEMPT_WINDOW = 10 * 60 * 1000;
const LOCKOUT_DURATION = 30 * 60 * 1000;

// Function to get or initialize attempt data from localStorage
function getAttemptData() {
    const data = localStorage.getItem('accessAttempts');
    return data ? JSON.parse(data) : { attempts: [], lockoutUntil: null };
}

// Function to save attempt data to localStorage
function saveAttemptData(data) {
    localStorage.setItem('accessAttempts', JSON.stringify(data));
}

// Function to check if user is rate-limited
function isRateLimited() {
    const data = getAttemptData();
    const now = Date.now();

    // Check if currently locked out
    if (data.lockoutUntil && now < data.lockoutUntil) {
        return { isLimited: true, timeLeft: data.lockoutUntil - now };
    }

    // Clean up attempts older than the window
    data.attempts = data.attempts.filter(timestamp => now - timestamp < ATTEMPT_WINDOW);

    // Check if too many attempts in window
    if (data.attempts.length >= MAX_ATTEMPTS) {
        data.lockoutUntil = now + LOCKOUT_DURATION;
        saveAttemptData(data);
        return { isLimited: true, timeLeft: LOCKOUT_DURATION };
    }

    return { isLimited: false };
}

function resetAllData() {
    // Create overlay and modal elements
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.id = 'resetConfirmOverlay';
    overlay.style.display = 'block';
    overlay.style.position = 'fixed';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.zIndex = '9999';
    
    const modal = document.createElement('div');
    modal.className = 'modal reset-modal';
    modal.style.display = 'block';
    modal.style.position = 'fixed';
    modal.style.top = '50%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)';
    modal.style.zIndex = '10000';
    modal.innerHTML = `
        <div class="modal-header">
            <h2>⚠️ Reset Options</h2>
            <button class="modal-close" onclick="closeResetConfirm()" aria-label="Close">×</button>
        </div>
        <div class="modal-body">
            <div class="warning-icon">⚠️</div>
            <p class="reset-warning">Select what you want to reset. This action cannot be undone.</p>

            <div class="settings-list" style="margin: 10px 0 20px;">
                <div class="setting-item">
                    <div class="setting-text">
                        <span class="setting-title">Appearance</span>
                        <small class="setting-desc">Theme and accent color</small>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="optResetAppearance" checked />
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <div class="setting-text">
                        <span class="setting-title">Keyboard Shortcuts</span>
                        <small class="setting-desc">Restore default shortcuts</small>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="optResetShortcuts" checked />
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <div class="setting-text">
                        <span class="setting-title">History & Stats</span>
                        <small class="setting-desc">Clear message history and counters</small>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="optClearHistory" checked />
                        <span class="toggle-slider"></span>
                    </label>
                </div>

                <div class="setting-item">
                    <div class="setting-text">
                        <span class="setting-title">Other Preferences</span>
                        <small class="setting-desc">Auto-copy, password requirement, motion, compact mode</small>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="optOtherPrefs" checked />
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>

            <div class="form-actions">
                <button class="button btn-secondary cancel-reset" onclick="closeResetConfirm()">
                    Cancel
                </button>
                <button class="button btn-danger confirm-reset" onclick="confirmReset()">
                    Reset Selected
                </button>
            </div>
        </div>
    `;
    
    // Add to DOM
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
    document.body.style.overflow = 'hidden';
}

function closeResetConfirm() {
    const overlay = document.getElementById('resetConfirmOverlay');
    const modal = document.querySelector('.reset-modal');
    
    if (overlay && modal) {
        overlay.remove();
        modal.remove();
        document.body.style.overflow = null;
    }
}

function confirmReset() {
    try {
        const resetAppearance = document.getElementById('optResetAppearance')?.checked;
        const resetShortcuts = document.getElementById('optResetShortcuts')?.checked;
        const clearHistory   = document.getElementById('optClearHistory')?.checked;
        const resetOther     = document.getElementById('optOtherPrefs')?.checked;

        // Appearance
        if (resetAppearance) {
            localStorage.removeItem('theme');
            localStorage.removeItem('accentColor');
            document.documentElement.setAttribute('data-theme', 'dark');
            document.documentElement.style.setProperty('--accent-color', '#4a6bff');
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) themeToggle.checked = false;
        }

        // Shortcuts
        if (resetShortcuts) {
            localStorage.removeItem('keyboardShortcuts');
            localStorage.removeItem('shortcutsEnabled');
        }

        // History & stats
        if (clearHistory) {
            localStorage.removeItem('messageHistory');
            localStorage.removeItem('encryptedCount');
            localStorage.removeItem('decryptedCount');
            localStorage.removeItem('activeMessages');
            localStorage.removeItem(STATS_KEY);
            if (typeof updateStatsUI === 'function') updateStatsUI();
        }

        // Other preferences
        if (resetOther) {
            localStorage.removeItem('requirePassword');
            localStorage.removeItem('autoCopy');
            localStorage.removeItem('reduceMotion');
            localStorage.removeItem('compactMode');
            localStorage.removeItem('autoSelfDestructEnabled');
            localStorage.removeItem('autoSelfDestructTime');

            // Clear any persisted SentryLock state
            localStorage.removeItem('sentryLockActive');
            localStorage.removeItem('sentryLockReason');
            localStorage.removeItem('sentryLockMissingFile');
            localStorage.removeItem('sentryLockTimestamp');
            try { sessionStorage.removeItem('lastWhitelistError'); } catch (e) {}

            const autoCopyEl = document.getElementById('autoCopy');
            const requirePwEl = document.getElementById('requirePassword');
            if (autoCopyEl) autoCopyEl.checked = false;
            if (requirePwEl) requirePwEl.checked = true;

            document.documentElement.removeAttribute('data-reduce-motion');
            document.documentElement.removeAttribute('data-compact-mode');
        }

        closeResetConfirm();
        showAlert('Selected data has been reset.', 'success');

        setTimeout(() => {
            location.reload();
        }, 1000);
    } catch (e) {
        console.error(e);
        showAlert('Failed to reset. Please try again.', 'error');
    }
}

// Function to record a failed attempt
function recordFailedAttempt() {
    const data = getAttemptData();
    const now = Date.now();

    // Add new attempt
    data.attempts.push(now);
    saveAttemptData(data);
}

// Function to format time left in minutes and seconds
function formatTimeLeft(ms) {
    const minutes = Math.floor(ms / (1000 * 60));
    const seconds = Math.floor((ms % (1000 * 60)) / 1000);
    return `${minutes}m ${seconds}s`;
}
    </script>

    <script>
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            const path = urlParams.get('path');
            const hash = window.location.hash.slice(1);
            
            // Show content by default for direct access or when using hash
            if (!path || hash) {
                document.querySelector('.container').style.display = 'block';
                return;
            }

            // btw this doesn't actually work, you're free to try but nothing'll happen :) -blake
            const username = path.toLowerCase();
            const authorizedUsers = ['admin', 'test'];
            
            if (!authorizedUsers.includes(username)) {
                document.querySelector('.container').style.display = 'none';
                blockUnauthorizedUser(username);
                return;
            }
            document.querySelector('.container').style.display = 'block';
        })();

        // Check for path= in password field
        document.getElementById('password').addEventListener('input', function(e) {
            const password = e.target.value;
            if (password.includes('test=block')) {
                const username = password.split('test=')[1].toLowerCase();
                if (!authorizedUsers.includes(username)) {
                    testblockAccess(username);
                }
            }
        });

        document.getElementById('password').addEventListener('input', function(e) {
            const password = e.target.value;
            if (password.includes('test=special')) {
                SentryLock();
            }
        });

        

        // Check URL parameter on load
        const urlParams = new URLSearchParams(window.location.search);
        const pathUser = urlParams.get('path');
        if (pathUser && !authorizedUsers.includes(pathUser.toLowerCase())) {
            blockAccess(pathUser.toLowerCase());
        }

        function blockAccess(username) {
            const rateLimitStatus = isRateLimited();
            const now = Date.now();
            const pathlol = window.location.pathname.split('/')[3] || username || 'unknown';

            document.querySelector('.container').style.display = 'none';
            const accessDenied = document.getElementById('access-denied');

            let html = `
                <div class="blocked-overlay">
                    <div class="blocked-content">
                        <div class="blocked-header">
                            <span class="blocked-icon">🚫</span>
                            <h2 class="blocked-title">Access Denied</h2>
                        </div>
                        <div class="blocked-body">
                            <p class="blocked-time">Detected: ${new Date().toLocaleTimeString()} on ${new Date().toLocaleDateString()}</p>
                            <p class="blocked-user"><strong>${pathlol}</strong>, you are not authorized to use this tool.</p>
                            <p class="blocked-info">This tool is protected by SentryLock, restricting access to authorized users only.</p>
                            <p class="blocked-contact">If this is an error, contact</p> 
                            <p style="color: white;">mcgahaj2@students.hcboe.net</p> 
                            <p>with your username and issue details.</p>
                        </div>
                        <div class="blocked-footer">
                            <p style="color: #F59E0B;" class="blocked-warning">⚠️ Incident Logged - SentryLock Enforced ⚠️</p>
                        </div>
                    </div>
                </div>
            `;

            if (rateLimitStatus.isLimited) {
                const timeLeft = formatTimeLeft(rateLimitStatus.timeLeft);
                html = `
                    <div class="blocked-overlay">
                        <div class="blocked-content">
                            <div class="blocked-header">
                                <span class="blocked-icon-locked">🔒</span>
                                <h2 class="blocked-title">Access Locked</h2>
                            </div>
                            <div class="blocked-body">
                                <p class="blocked-time">Too many attempts detected at ${new Date().toLocaleTimeString()} on ${new Date().toLocaleDateString()}</p>
                                <p class="blocked-user"><strong>${pathlol}</strong>, access is locked.</p>
                                <p class="blocked-info">Cooldown: <strong>${timeLeft}</strong> remaining.</p>
                                <p class="blocked-contact">Retry after cooldown or contact <a href="mailto:mcgahaj2@students.hcboe.net">mcgahaj2@students.hcboe.net</a>.</p>
                            </div>
                            <div class="blocked-footer">
                                <p class="blocked-warning">⚠️ Incident Logged - SentryLock Enforced ⚠️</p>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                recordFailedAttempt();
                logUnauthorizedAccess(pathlol);
            }

            accessDenied.innerHTML = html;
            accessDenied.style.display = 'block';
            document.body.style.overflow = 'hidden';

            if (rateLimitStatus.isLimited) {
                const countdownInterval = setInterval(() => {
                    const remaining = rateLimitStatus.timeLeft - (Date.now() - now);
                    if (remaining <= 0) {
                        clearInterval(countdownInterval);
                        localStorage.removeItem('accessAttempts');
                        accessDenied.innerHTML += `<div class="blocked-footer"><button class="button" onclick="location.reload()">Retry Now</button></div>`;
                    } else {
                        document.querySelector('.blocked-info').innerHTML = `Cooldown: <strong>${formatTimeLeft(remaining)}</strong> remaining.`;
                    }
                }, 1000);
            }
        }

        // Theme toggling
        function toggleTheme() {
            const body = document.documentElement;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            const toggle = document.getElementById('themeToggle');
            
            toggle.disabled = true; // Disable during transition
            body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            
            setTimeout(() => {
                toggle.disabled = false; // Re-enable after 1s
            }, 1000);
        }

        // Load saved theme
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            document.documentElement.setAttribute('data-theme', savedTheme);
            // Update toggle state when DOM is loaded
            document.addEventListener('DOMContentLoaded', function() {
                const themeToggle = document.getElementById('themeToggle');
                if (themeToggle) {
                    themeToggle.checked = (savedTheme === 'dark');
                }
            });
        }

        // File upload handling
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);

        // Clear all fields
        function clearAll() {
            document.getElementById('password').value = '';
            document.getElementById('inputText').value = '';
            document.getElementById('resultText').value = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('selfDestructTime').value = '';
            document.getElementById('timeRemaining').textContent = '';
            
            // Clear any existing timer
            if (currentExpiryTimer) {
                clearInterval(currentExpiryTimer);
                currentExpiryTimer = null;
            }
            
            hideAllAlerts();
        }

        function openPageLayoutSettings() {
            const overlay = document.getElementById('pageLayoutOverlay');
            const modal = document.getElementById('pageLayoutModal');
            overlay.style.display = 'block';
            modal.style.display = 'block';
        }

        function closePageLayoutSettings() {
            const overlay = document.getElementById('pageLayoutOverlay');
            const modal = document.getElementById('pageLayoutModal');
            overlay.style.display = 'none';
            modal.style.display = 'none';
        }

        // Copy result to clipboard
        function copyResult(isAutoCopy = false) {
            const resultText = document.getElementById('resultText').value;
            navigator.clipboard.writeText(resultText).then(() => {
                if (isAutoCopy) {
                    showAlert('Result automatically copied to clipboard!', 'auto-copy');
                } else {
                     showAlert('Message copied to clipboard', 'success');
                }
            }).catch(err => {
                showAlert(`Failed to copy: ${err.message}`, 'error');
            });
        }

        // Download result as file
        function downloadResult() {
            const text = document.getElementById('resultText').value;
            if (!text) {
                showAlert('No content to save', 'error');
                return;
            }
            
            const blob = new Blob([text], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = window.URL.createObjectURL(blob);
            a.download = 'secure-message.txt';
            a.click();
            window.URL.revokeObjectURL(a.href);
        }

        // Alert system (redesign): queue, actions, pause on hover/blur, swipe-to-dismiss, ARIA
        const ALERT_MAX_VISIBLE = 3;
        const alertIcons = { success: '✓', error: '✕', warning: '⚠', info: 'ℹ', 'auto-copy': '📋' };
        const alertTitles = { success: 'Success', error: 'Error', warning: 'Warning', info: 'Info', 'auto-copy': 'Auto Copy' };
        let alertCounter = 0;
        const activeAlerts = new Map();
        const alertQueue = [];

        function computeDuration(message, explicit) {
            if (explicit === 0) return Infinity; // sticky
            if (typeof explicit === 'number') return explicit;
            return Math.max(4000, Math.min(9000, 5000 + String(message).length * 25));
        }

        // Backward-compatible signature: showAlert(message, type?, duration?)
        // New signature: showAlert({ message, type, duration, actions: [{label, onClick}], dismissible, id })
        function showAlert(arg1, type = 'info', duration = null) {
            const isOptions = typeof arg1 === 'object' && arg1 !== null && 'message' in arg1;
            const opts = isOptions ? arg1 : { message: arg1, type, duration };
            const kind = opts.type || 'info';
            const id = opts.id || `alert-${alertCounter++}`;
            // Choose container: normal vs banner
            let container = document.getElementById('alertContainer');
            if (opts.variant === 'banner') {
                container = document.getElementById('alertBannerContainer');
                if (!container) {
                    container = document.createElement('div');
                    container.id = 'alertBannerContainer';
                    document.body.appendChild(container);
                }
            }
            const dur = computeDuration(opts.message, opts.duration);
            const dismissible = opts.dismissible !== false; // default true
            const actions = Array.isArray(opts.actions) ? opts.actions.slice(0, 3) : [];

            const makeAlertEl = () => {
                const el = document.createElement('div');
                el.className = `alert alert-${kind}${opts.variant === 'banner' ? ' alert--banner' : ''}`;
                el.id = id;
                el.setAttribute('role', 'alert');
                el.setAttribute('aria-live', 'polite');

                const actionsHtml = actions.map((a, i) => `<button class="alert-action" data-action-index="${i}">${a.label}</button>`).join('');
                el.innerHTML = `
                    <div class="alert-icon">${alertIcons[kind] || ''}</div>
                    <div class="alert-content">
                        <h4 class="alert-title">${alertTitles[kind] || 'Notice'}</h4>
                        <p class="alert-message">${opts.message}</p>
                        ${actions.length ? `<div class="alert-actions">${actionsHtml}</div>` : ''}
                    </div>
                    ${dismissible ? `<button class="alert-close" aria-label="Dismiss" title="Dismiss">${alertIcons.error}</button>` : ''}
                    <div class="alert-progress"><div class="alert-progress-bar"></div></div>
                `;
                return el;
            };

            const scheduleDisplay = () => {
                if (container.children.length >= ALERT_MAX_VISIBLE) {
                    alertQueue.push({ opts, id });
                    return;
                }

                const el = makeAlertEl();
                container.appendChild(el);
                // Force reflow and show
                // eslint-disable-next-line no-unused-expressions
                el.offsetHeight; el.classList.add('show');

                const state = { element: el, remaining: dur, start: Date.now(), timer: null, paused: false, dur };
                const progressBar = el.querySelector('.alert-progress-bar');
                if (Number.isFinite(dur)) {
                    progressBar.style.transition = `transform ${dur}ms linear`;
                    progressBar.style.transform = 'scaleX(0)';
                    state.timer = setTimeout(() => hideAlert(id), dur);
                } else {
                    el.classList.add('sticky');
                }

                // Events: close button
                if (dismissible) {
                    el.querySelector('.alert-close').addEventListener('click', () => hideAlert(id));
                    el.classList.add('clickable');
                    el.addEventListener('click', (e) => {
                        if (e.target.closest('.alert-action') || e.target.closest('.alert-close')) return;
                        hideAlert(id);
                    });
                }

                // Actions
                if (actions.length) {
                    el.querySelectorAll('.alert-action').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const idx = Number(e.currentTarget.getAttribute('data-action-index'));
                            try { actions[idx]?.onClick?.(); } catch { /* noop */ }
                            hideAlert(id);
                        });
                    });
                }

                // Pause on hover
                const pause = () => {
                    if (state.paused || !Number.isFinite(state.dur)) return;
                    state.paused = true;
                    clearTimeout(state.timer);
                    const elapsed = Date.now() - state.start;
                    state.remaining = Math.max(0, state.remaining - elapsed);
                    const fraction = state.remaining / state.dur;
                    progressBar.style.transition = 'none';
                    progressBar.style.transform = `scaleX(${isFinite(fraction) ? fraction : 0})`;
                };
                const resume = () => {
                    if (!state.paused || !Number.isFinite(state.dur)) return;
                    state.paused = false;
                    state.start = Date.now();
                    // ensure next frame so transition applies from the current transform
                    requestAnimationFrame(() => {
                        progressBar.style.transition = `transform ${state.remaining}ms linear`;
                        progressBar.style.transform = 'scaleX(0)';
                        state.timer = setTimeout(() => hideAlert(id), state.remaining);
                    });
                };
                el.addEventListener('mouseenter', pause);
                el.addEventListener('mouseleave', resume);

                // Pause on window blur, resume on focus
                const onBlur = () => pause();
                const onFocus = () => resume();
                window.addEventListener('blur', onBlur);
                window.addEventListener('focus', onFocus);
                state.onBlur = onBlur; state.onFocus = onFocus;

                // Swipe/drag to dismiss
                let startX = 0; let currentX = 0; let dragging = false;
                const threshold = 80;
                const onPointerDown = (e) => { dragging = true; startX = (e.touches?.[0]?.clientX) ?? e.clientX; el.classList.add('dragging'); };
                const onPointerMove = (e) => {
                    if (!dragging) return;
                    currentX = (e.touches?.[0]?.clientX) ?? e.clientX;
                    const dx = currentX - startX;
                    el.style.transform = `translateX(${dx}px)`;
                    el.style.opacity = String(1 - Math.min(0.6, Math.abs(dx) / 200));
                };
                const onPointerUp = () => {
                    if (!dragging) return;
                    dragging = false;
                    const dx = currentX - startX;
                    el.classList.remove('dragging');
                    el.style.transform = '';
                    el.style.opacity = '';
                    if (Math.abs(dx) > threshold) hideAlert(id);
                };
                el.addEventListener('mousedown', onPointerDown);
                el.addEventListener('mousemove', onPointerMove);
                el.addEventListener('mouseup', onPointerUp);
                el.addEventListener('touchstart', onPointerDown, { passive: true });
                el.addEventListener('touchmove', onPointerMove, { passive: true });
                el.addEventListener('touchend', onPointerUp);

                activeAlerts.set(id, state);
            };

            scheduleDisplay();
            return id;
        }

        function hideAlert(id) {
            const state = activeAlerts.get(id);
            if (!state) return;
            clearTimeout(state.timer);
            const { element } = state;
            element.classList.add('hiding');
            element.addEventListener('transitionend', () => {
                element.remove();
                activeAlerts.delete(id);
                // cleanup global listeners
                if (state.onBlur) window.removeEventListener('blur', state.onBlur);
                if (state.onFocus) window.removeEventListener('focus', state.onFocus);
                // Show next from queue if any
                const next = alertQueue.shift();
                if (next) showAlert(next.opts);
            }, { once: true });
        }

        function hideAllAlerts() {
            Array.from(activeAlerts.keys()).forEach(id => hideAlert(id));
            alertQueue.length = 0;
        }

        // =========================
        // Version check banner alert
        // =========================
        const CURRENT_VERSION_FALLBACK = '4.0.3';

        function getCurrentAppVersion() {
            // Try read from About tab text
            const about = document.querySelector('#tab-about .setting-item span');
            if (about) {
                const m = about.textContent.match(/V(\d+\.\d+\.\d+)/i);
                if (m) return m[1];
            }
            return CURRENT_VERSION_FALLBACK;
        }

        async function fetchRemoteVersion(endpoint) {
            const url = endpoint;
            const body = { action: 'getVersion' };
            const resp = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
                mode: 'no-cors' // Apps Script often needs no-cors
            }).catch(() => null);
            // With no-cors, we can't read body; fallback to a JSONP-like endpoint not provided.
            // As a workaround, also try a form-encoded request.
            if (!resp || (resp && resp.type === 'opaque')) {
                try {
                    const form = new URLSearchParams();
                    form.set('action', 'getVersion');
                    const r2 = await fetch(url, { method: 'POST', body: form });
                    const json = await r2.json();
                    return json;
                } catch {
                    return { ok: false, error: 'Fetch blocked' };
                }
            }
            try {
                const json = await resp.json();
                return json;
            } catch {
                return { ok: false, error: 'Invalid JSON' };
            }
        }

        async function checkVersionRemote() {
            try {
                const endpoint = localStorage.getItem('messageServiceEndpoint');
                if (!endpoint) return; // silent if no backend configured
                const res = await fetchRemoteVersion(endpoint);
                const current = getCurrentAppVersion();
                if (res && res.ok && res.version) {
                    if (String(res.version).trim() !== String(current).trim()) {
                        const msg = `A new version is available. Your version: v${current}. Latest: v${res.version}. <br>Please run the update.hta file in the download folder to update.</br>`;
                        showAlert({
                            message: msg,
                            type: 'warning',
                            duration: 0, // sticky
                            variant: 'banner',
                            actions: [
                                { 
                                    label: 'Dismiss', 
                                    onClick: () => {} 
                                }
                            ]
                        });
                    }
                }
            } catch (e) {
                // noop
            }
        }

        // Check encryption functionality on page load
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Test encryption
                const testKey = await window.crypto.subtle.generateKey(
                    { name: "AES-GCM", length: 256 },
                    true,
                    ["encrypt", "decrypt"]
                );
                const testData = new Uint8Array(8);
                window.crypto.getRandomValues(testData);
                await window.crypto.subtle.encrypt(
                    { name: "AES-GCM", iv: new Uint8Array(12) },
                    testKey,
                    testData
                );
            } catch (e) {
                showAlert('⚠️ Warning: Your browser may not support secure encryption. Please use a modern browser like Chrome, Firefox, or Edge.', 'warning', 0);
            }
        });

        // convert password into a cryptographic key using SHA-256
        async function deriveKey(password, salt) {
            const encoder = new TextEncoder();
            const baseKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password), // Convert password string to Uint8Array
                { name: 'PBKDF2' },
                false,
                ['deriveBits'] // We’ll derive bits, not a key directly
            );

            const keyBits = await crypto.subtle.deriveBits(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-256'
                },
                baseKey,
                256 // 256-bit key for AES-256-GCM
            );

            return new Uint8Array(keyBits); // Return as Uint8Array, a valid BufferSource
        }

        // Input validation
        function validateInput() {
    const password = document.getElementById('password').value;
    const inputText = document.getElementById('inputText').value;

    // Check if password is required and validate it
    if (isPasswordRequired) {
        if (!password) {
            showAlert('Password is required', 'error');
            document.getElementById('password').focus();
            return false;
        }
        if (password.length < 8) {
            showAlert('Password must be at least 8 characters long', 'error');
            document.getElementById('password').focus();
            return false;
        }
        if (password.length > 100) {
            showAlert('Password is too long (maximum 100 characters)', 'error');
            document.getElementById('password').focus();
            return false;
        }
    }

    // Validate message
    if (!inputText) {
        showAlert('Please enter a message', 'error');
        document.getElementById('inputText').focus();
        return false;
    }

    if (inputText.length > 10000) {
        showAlert('Message is too long (maximum 10000 characters)', 'error');
        return false;
    }

    return true;
}

        // File validation
        function validateFile(file) {
            const maxSize = 1024 * 1024; // 1MB
            
            if (file.size > maxSize) {
                throw new Error('File is too large (maximum 1MB)');
            }

            if (!file.type.match('text.*') && !file.name.endsWith('.txt')) {
                throw new Error('Only text files are supported');
            }

            return true;
        }

        // Improved file handling
        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                validateFile(file);
                const content = await readFileAsync(file);
                
                if (content.length > 10000) {
                    throw new Error('File content is too long (maximum 10000 characters)');
                }

                document.getElementById('inputText').value = content;
                showAlert('File uploaded successfully!', 'success');
            } catch (error) {
                showAlert(`Failed to read file: ${error.message}`, 'error');
                e.target.value = ''; // Clear the file input
            }
        }

        // Promise-based file reader
        function readFileAsync(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }    

        // Global variable to track the current timer
        let currentExpiryTimer = null;

        // Update expiry timer
        function updateExpiryTimer(expiryTime) {
            const timeRemainingElement = document.getElementById('timeRemaining');
            if (!timeRemainingElement || !expiryTime) return;

            // Clear any existing timer
            if (currentExpiryTimer) {
                clearInterval(currentExpiryTimer);
                currentExpiryTimer = null;
            }

            const updateTimer = () => {
                const now = Date.now();
                const timeLeft = expiryTime - now;

                if (timeLeft <= 0) {
                    timeRemainingElement.textContent = 'Message has expired';
                    document.getElementById('resultText').value = '';
                    showAlert('Message has expired and has been cleared', 'warning');
                    if (currentExpiryTimer) {
                        clearInterval(currentExpiryTimer);
                        currentExpiryTimer = null;
                    }
                    return;
                }

                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

                timeRemainingElement.textContent = `Expires in: ${hours}h ${minutes}m ${seconds}s`;
            };

            updateTimer();
            currentExpiryTimer = setInterval(updateTimer, 1000);
        }

        // Set today at 3:00 PM
        function setToday3PM() {
            const today = new Date();
            today.setHours(15, 0, 0, 0);
	        showAlert("Setting to Today at 3PM.", 'success');
            
            // If it's already past 3 PM, show an alert
            if (Date.now() > today.getTime()) {
                showAlert("It's already past 3 PM today. Setting to tomorrow at 3 PM instead.", 'info');
                today.setDate(today.getDate() + 1);
            }
            
            // Format for datetime-local input
            today.setMinutes(today.getMinutes() - today.getTimezoneOffset()); // Handle timezone
            const formattedDate = today.toISOString().slice(0, 16);
            document.getElementById('selfDestructTime').value = formattedDate;
        }

        // Set min datetime to now
        document.addEventListener('DOMContentLoaded', function() {
            const selfDestructInput = document.getElementById('selfDestructTime');
            const now = new Date();
            now.setMinutes(now.getMinutes() - now.getTimezoneOffset()); // Handle timezone
            selfDestructInput.min = now.toISOString().slice(0, 16);
        });

        // Password visibility toggle
        function togglePassword() {
            const input = document.getElementById('password');
            const button = document.querySelector('.password-toggle');
            if (input.type === 'password') {
                input.type = 'text';
                button.textContent = '👁️‍🗨️';
            } else {
                input.type = 'password';
                button.textContent = '👁️';
            }
        }

        document.querySelectorAll('button').forEach(button => {
            if (!button.classList.contains('theme-toggle') && !button.classList.contains('password-toggle')) {
                button.classList.add('button');
            }
        });

        // Self-destruct time functions
        function setFutureTime(minutes) {
            const future = new Date();
            future.setMinutes(future.getMinutes() + minutes);
            
            // Format for datetime-local input
            future.setMinutes(future.getMinutes() - future.getTimezoneOffset());
            const formattedDate = future.toISOString().slice(0, 16);
            document.getElementById('selfDestructTime').value = formattedDate;
            
            // Show confirmation
            const timeStr = minutes < 60 
                ? `${minutes} minutes` 
                : `${minutes/60} hour${minutes/60 > 1 ? 's' : ''}`;
            showAlert(`⏰ Set to self-destruct in ${timeStr}`, 'info', 3000);
        }

        function updateStats() {
            const stats = {
                encrypted: 0,
                decrypted: 0,
                active: 0
            };

            document.getElementById('encryptedCount').textContent = stats.encrypted;
            document.getElementById('decryptedCount').textContent = stats.decrypted;
        }

        // Safely encode string to base64
        function safeBase64Encode(str) {
            try {
                return btoa(unescape(encodeURIComponent(str)));
            } catch (e) {
                console.error('Base64 encoding error:', e);
                return btoa(unescape(encodeURIComponent(str.substring(0, 100))));
                SentryLock();
            }
        }

        // Track if we've shown messages
        let hasShownWelcomeMessage = false;
        let lastSpecialUser = null;
        let lastPassword = '';

        // Increment failed login attempts and handle lockout
        window.incrementFailedAttempts = function() {
            failedAttempts++;
            const now = Date.now();
            
            if (failedAttempts >= PASSWORD_MAX_ATTEMPTS) {
                lockoutEndTime = now + PASSWORD_LOCKOUT_DURATION;
                const minutes = PASSWORD_LOCKOUT_DURATION / 60000;
                
                const passwordInput = document.getElementById('password');
                if (passwordInput) {
                    passwordInput.disabled = true;
                    
                    // Re-enable after lockout period
                    setTimeout(() => {
                        if (passwordInput) {
                            passwordInput.disabled = false;
                            failedAttempts = 0;
                            lockoutEndTime = 0;
                        }
                    }, PASSWORD_LOCKOUT_DURATION);
                }
                
                showAlert(`Too many failed attempts. Account locked for ${minutes} minutes.`, 'error');
                return true; // Indicates account is now locked
            }
            
            const remainingAttempts = PASSWORD_MAX_ATTEMPTS - failedAttempts;
            showAlert(`Incorrect password. ${remainingAttempts} attempt${remainingAttempts === 1 ? '' : 's'} remaining.`, 'error');
            
            return false; // Account not locked yet
        };
        let specialTimeout = null;

        // Function to log unauthorized access
        

    function calculateChecksum(str) {
        // Extract only the script content for checksum
        const scriptContent = str.match(/<script>([\s\S]*)<\/script>/)?.[1] || '';
        let hash = 0;
        for (let i = 0; i <scriptContent.length; i++) {
            const char = scriptContent.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return hash;
    }

    // Check for code tampering on load
    document.addEventListener('DOMContentLoaded', async function() {
        // Check core encryption functions immediately
        try {
            // Test encryption
            const testMessage = "test";
            const testPassword = "testPassword123";
            
            // Validate core functions exist
            if (typeof encryptMessage !== 'function' || 
                typeof decryptMessage !== 'function' ||
                typeof SentryLock !== 'function') {
                throw new Error("Core functions missing");
            }

            // Generate test key
            const testKey = await window.crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt", "decrypt"]
            );

            // Test crypto operations
            const testData = new TextEncoder().encode(testMessage);
            const testIv = crypto.getRandomValues(new Uint8Array(12));
            
            await crypto.subtle.encrypt(
                { name: "AES-GCM", iv: testIv },
                testKey,
                testData
            );

        } catch (error) {
            console.error("Encryption system check failed:", error);
            SentryLock();
            return;
        }

        // Continue with regular checksum validation
        const originalContent = document.documentElement.outerHTML;
        const originalChecksum = calculateChecksum(originalContent);
        let tamperedDetected = false;
        
        setInterval(() => {
            if (tamperedDetected) return;
            
            const currentContent = document.documentElement.outerHTML;
            const currentChecksum = calculateChecksum(currentContent);
            
            if (currentChecksum !== originalChecksum) {
                tamperedDetected = true;
                console.clear();
                SentryLock();
            }
        }, 5000);
    });

    // Settings Panel Functions (refactored)
    let settingsPreviousFocus = null;
    let settingsKeydownHandler = null;

    function getSettingsFocusable() {
        const panel = document.getElementById('settingsPanel');
        return panel.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
    }

    function openSettings() {
        const overlay = document.getElementById('settingsOverlay');
        const panel = document.getElementById('settingsPanel');
        const btn = document.getElementById('settingsBtn');
        const settingsUsername = document.getElementById('settingsUsername');
        
        // Show loading state for username
        if (settingsUsername && !settingsUsername.textContent) {
            settingsUsername.textContent = 'Loading...';
            settingsUsername.classList.add('username-loading');
        }

        settingsPreviousFocus = document.activeElement;

        // Show overlay and panel
        overlay.style.display = 'block';
        // ARIA: overlay must not be hidden while it or its descendants have focus
        overlay.setAttribute('aria-hidden', 'false');
        requestAnimationFrame(() => {
            overlay.classList.add('active');
            panel.classList.add('active');
            document.body.style.overflow = 'hidden';
            if (btn) btn.setAttribute('aria-expanded', 'true');
        
        // Ensure transitions work by forcing a reflow
        void overlay.offsetHeight;

        // Ensure correct tab/panel are shown immediately on open (prevents double-click issue)
        try {
            const desired = localStorage.getItem('lastActiveTab') || 'general';
            const tabsAll = document.querySelectorAll('.settings-tab');
            const panelsAll = document.querySelectorAll('.settings-section');
            panelsAll.forEach(p => { p.hidden = true; p.setAttribute('aria-hidden', 'true'); });
            let selPanel = document.getElementById(`tab-${desired}`);
            if (!selPanel) selPanel = document.getElementById('tab-general');
            if (selPanel) { selPanel.hidden = false; selPanel.setAttribute('aria-hidden', 'false'); selPanel.style.display = 'block'; }
            tabsAll.forEach(t => { t.classList.remove('active'); t.setAttribute('aria-selected', 'false'); });
            let selTab = document.querySelector(`.settings-tab[data-tab="${desired}"]`);
            if (!selTab) selTab = document.querySelector(`.settings-tab[data-tab="general"]`);
            if (selTab) { selTab.classList.add('active'); selTab.setAttribute('aria-selected', 'true'); }
        } catch (_) {}

        // Restore search value from localStorage (apply only if non-empty)
        const searchInput = document.getElementById('settingsSearchInput');
        const saved = (localStorage.getItem('settingsSearch') || '').trim();
        if (searchInput) {
            searchInput.value = saved;
        }
        if (searchInput && saved) {
            filterSettings(saved);
        } else {
            // Ensure current panel is fully visible when no saved filter
            const currentPanel = document.querySelector('.settings-section:not([hidden])');
            if (currentPanel) {
                currentPanel.querySelectorAll('.setting-item').forEach(it => { it.style.display = 'flex'; });
            }
        }

        // Focus trap setup
        const focusables = getSettingsFocusable();
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        if (searchInput) {
            panel.focus(); // ensure panel is focusable for screen readers
            searchInput.focus();
        } else if (first) {
            first.focus();
        }

        settingsKeydownHandler = function(e) {
            if (e.key === 'Escape') {
                e.preventDefault();
                closeSettings();
                return;
            }
            if (e.key === 'Tab' && focusables.length > 0) {
                // Recompute in case DOM changed
                const f = getSettingsFocusable();
                const firstEl = f[0];
                const lastEl = f[f.length - 1];
                if (e.shiftKey) {
                    if (document.activeElement === firstEl) {
                        e.preventDefault();
                        lastEl.focus();
                    }
                } else {
                    if (document.activeElement === lastEl) {
                        e.preventDefault();
                        firstEl.focus();
                    }
                }
            }
        };
        panel.addEventListener('keydown', settingsKeydownHandler);
    });
    }
    function closeSettings() {
        const overlay = document.getElementById('settingsOverlay');
        const panel = document.getElementById('settingsPanel');
        const btn = document.getElementById('settingsBtn');
        
        // Start closing animation
        overlay.classList.remove('active');
        panel.classList.remove('active');
        document.body.style.overflow = null;
        if (btn) btn.setAttribute('aria-expanded', 'false');
        
        // Remove overlay after animation completes
        setTimeout(() => {
            if (!panel.classList.contains('active')) {
                overlay.style.display = 'none';
                // ARIA: mark overlay hidden only after it's closed and unfocused
                overlay.setAttribute('aria-hidden', 'true');
            }
        }, 300); // Match this with your CSS transition duration

        if (settingsKeydownHandler) {
            panel.removeEventListener('keydown', settingsKeydownHandler);
            settingsKeydownHandler = null;
        }
        if (settingsPreviousFocus && typeof settingsPreviousFocus.focus === 'function') {
            settingsPreviousFocus.focus();
        }
    }

    function toggleSettings(event) {
        const overlay = document.getElementById('settingsOverlay');
        const panel = document.getElementById('settingsPanel');
        const isOpen = overlay.classList.contains('active');
        
        // Close if clicking on overlay or escape key
        if (event && (event.target === overlay || event.key === 'Escape')) {
            closeSettings();
            return;
        }
        
        if (!isOpen) {
            openSettings();
        } else {
            closeSettings();
        }
    }

function stopPropagation(event) {
    event.stopPropagation(); // Prevent clicks inside the panel from reaching the overlay
}

function filterSettings(searchTerm) {
    const q = String(searchTerm || '').toLowerCase();
    const loading = document.getElementById('searchLoading');
    const currentPanel = document.querySelector('.settings-section:not([hidden])');
    const items = currentPanel ? currentPanel.querySelectorAll('.setting-item') : document.querySelectorAll('.setting-item');

    if (loading) loading.classList.add('active');
    setTimeout(() => {
        items.forEach(item => {
            const attr = item.getAttribute('data-name') || '';
            const titleEl = item.querySelector('.setting-title');
            const fallback = titleEl ? titleEl.textContent : '';
            const name = String(attr || fallback || '').toLowerCase();
            item.style.display = !q || name.includes(q) ? 'flex' : 'none';
        });
        if (loading) loading.classList.remove('active');
    }, 250);
    try { localStorage.setItem('settingsSearch', q); } catch(e) {}
}

// Session lock state
let isSessionLocked = false;
let lastUnlockAttempt = 0;
const UNLOCK_DELAY = 1000; // 1 second delay
let lastLockInteraction = 0; // timestamp of last user interaction on lock screen
// Lockout state helpers (persist via IndexedDB to survive localStorage clears)
const LOCKOUT_DB = 'AppSecure';
const LOCKOUT_STORE = 'lockout';
const LOCKOUT_KEY = 'global';

function idbOpen() {
    return new Promise((resolve, reject) => {
        try {
            const req = indexedDB.open(LOCKOUT_DB, 1);
            req.onupgradeneeded = (e) => {
                const db = req.result;
                if (!db.objectStoreNames.contains(LOCKOUT_STORE)) {
                    db.createObjectStore(LOCKOUT_STORE);
                }
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
        } catch (e) { reject(e); }
    });
}

async function readLockout() {
    let data = { nextUnlockAt: 0, failCount: 0 };
    try {
        const db = await idbOpen();
        const tx = db.transaction(LOCKOUT_STORE, 'readonly');
        const store = tx.objectStore(LOCKOUT_STORE);
        const val = await new Promise((resolve, reject) => {
            const r = store.get(LOCKOUT_KEY);
            r.onsuccess = () => resolve(r.result);
            r.onerror = () => reject(r.error);
        });
        if (val && typeof val === 'object') data = Object.assign(data, val);
    } catch (_) {
        // Fallback mirror from localStorage if IDB unavailable
        try { data = JSON.parse(localStorage.getItem('lockoutState') || '{}') || data; } catch(_) {}
        data.nextUnlockAt = Number(data.nextUnlockAt || 0);
        data.failCount = Number(data.failCount || 0);
    }
    return data;
}

async function writeLockout(state) {
    const payload = { nextUnlockAt: Number(state.nextUnlockAt || 0), failCount: Number(state.failCount || 0) };
    try {
        const db = await idbOpen();
        const tx = db.transaction(LOCKOUT_STORE, 'readwrite');
        const store = tx.objectStore(LOCKOUT_STORE);
        await new Promise((resolve, reject) => {
            const r = store.put(payload, LOCKOUT_KEY);
            r.onsuccess = () => resolve();
            r.onerror = () => reject(r.error);
        });
    } catch (_) {
        // Mirror to localStorage as a best-effort fallback
        try { localStorage.setItem('lockoutState', JSON.stringify(payload)); } catch(_) {}
    }
}

async function clearLockout() { await writeLockout({ nextUnlockAt: 0, failCount: 0 }); }

function backoffDelayMs(failCount) {
    const base = 3000; // 3s initial
    const max = 120000; // cap at 120s
    const n = Math.max(1, Number(failCount || 1));
    const d = base * Math.pow(2, n - 1);
    return Math.min(d, max);
}

let lockoutTimer = null;
function showLockoutCountdown(untilTs) {
    const passwordInput = document.getElementById('lockPassword');
    const unlockBtn = document.querySelector('#lockScreen .btn.btn-primary');
    if (passwordInput) passwordInput.disabled = true;
    if (unlockBtn) unlockBtn.disabled = true;
    let msgEl = document.getElementById('lockoutMsg');
    if (!msgEl) {
        msgEl = document.createElement('div');
        msgEl.id = 'lockoutMsg';
        msgEl.className = 'attempts-warning';
        const form = document.querySelector('#lockScreen .lock-form');
        if (form) form.appendChild(msgEl);
    }
    const tick = () => {
        const now = Date.now();
        const remaining = Math.max(0, untilTs - now);
        const secs = Math.ceil(remaining / 1000);
        msgEl.textContent = `Too many attempts. Try again in ${secs}s`;
        if (remaining <= 0) {
            clearInterval(lockoutTimer); lockoutTimer = null;
            if (passwordInput) passwordInput.disabled = false;
            if (unlockBtn) unlockBtn.disabled = false;
            msgEl.textContent = '';
        }
    };
    if (lockoutTimer) { clearInterval(lockoutTimer); lockoutTimer = null; }
    tick();
    lockoutTimer = setInterval(tick, 1000);
}

function setupSessionLock() {
    const password = prompt('Enter a new lock password:');
    if (password && password.length >= 4) {
        const hashedPassword = btoa(encodeURIComponent(password));
        localStorage.setItem('sessionLockPassword', hashedPassword);
        showAlert('Session lock password set!', 'success');
        
        // Ask if user wants to lock now
        if (confirm('Would you like to lock the session now?')) {
            lockSession();
        }
    } else if (password !== null) {
        showAlert('Password must be at least 4 characters', 'error');
    }
}

function lockSession() {
    // Don't clear memory to prevent losing important data
    console.log('Locking session...');
            
    try {
        // Safety: do not lock if no session password is configured
        const hasPassword = !!localStorage.getItem('sessionLockPassword');
        if (!hasPassword) {
            showAlert('Session lock password is not set. Please set a password first (Settings → Shortcuts → Set Lock Password).', 'warning');
            return;
        }
        // Set lock state with timestamp
        const lockState = {
            locked: true,
            timestamp: Date.now(),
            signature: ''
        };
        setLockState(lockState);
                
        // Add beforeunload handler to prevent accidental tab closing
        window.addEventListener('beforeunload', preventTabClose);
                
        isSessionLocked = true;
        const lockScreen = document.getElementById('lockScreen');
        if (lockScreen) {
            lockScreen.style.display = 'flex';
        }
        document.body.classList.add('locked');
        // Initialize interaction tracking and unlock nonce
        try {
            lastLockInteraction = Date.now();
            const btn = document.querySelector('#lockScreen .btn.btn-primary');
            const nonce = Math.random().toString(36).slice(2) + Date.now().toString(36);
            sessionStorage.setItem('unlockNonce', nonce);
            if (btn) btn.setAttribute('data-nonce', nonce);
            const updateInteraction = () => { lastLockInteraction = Date.now(); };
            lockScreen.addEventListener('pointerdown', updateInteraction, { passive: true });
            lockScreen.addEventListener('keydown', updateInteraction, { passive: true });
        } catch(_) {}
                
        // Blur any focused element outside the lock screen
        try {
            const active = document.activeElement;
            const lockRoot = document.getElementById('lockScreen');
            if (active && lockRoot && !lockRoot.contains(active) && typeof active.blur === 'function') {
                active.blur();
            }
        } catch(_) {}

        // Inert all top-level UI outside the lock screen to prevent focus and interaction
        try {
            const lockRoot = document.getElementById('lockScreen');
            Array.from(document.body.children).forEach(node => {
                if (lockRoot && node !== lockRoot) {
                    node.setAttribute('inert', '');
                }
            });
        } catch(_) {}
                
        // Focus the password field
        setTimeout(() => {
            const lockPass = document.getElementById('lockPassword');
            if (lockPass) {
                lockPass.focus();
                lockPass.value = ''; // Clear any previous password
            }
        }, 100);
                
    } catch (error) {
        console.error('Error during session lock:', error);
        // If locking fails, ensure we don't leave the UI in a broken state
        isSessionLocked = false;
        document.body.classList.remove('locked');
        const lockScreen = document.getElementById('lockScreen');
        if (lockScreen) {
            lockScreen.style.display = 'none';
        }
    }
}

// Prevent tab/window close when locked
function preventTabClose(e) {
    if (isSessionLocked) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
    }
}


async function unlockSession(e) {
    const now = Date.now();
    if (now - lastUnlockAttempt < UNLOCK_DELAY) {
        showAlert('Please wait before trying again', 'warning');
        return;
    }
    lastUnlockAttempt = now;
    // Guards: must be a user-initiated event targeting the lock screen
    try {
        // Require a trusted user event (blocks console/script-triggered calls)
        if (!e || e.isTrusted !== true) {
            showAlert('Unlock must be initiated by a user action.', 'error');
            return;
        }
        // Require interaction within the last 5 seconds on the lock screen
        if (Date.now() - lastLockInteraction > 5000) {
            showAlert('No recent interaction detected. Try again.', 'warning');
            return;
        }
        // Focus must be inside lock screen
        const active = document.activeElement;
        const lockRoot = document.getElementById('lockScreen');
        if (!lockRoot || !lockRoot.contains(active)) {
            showAlert('Please use the lock screen to unlock.', 'error');
            return;
        }
        // Nonce check ties the attempt to the runtime lock session
        const btn = active.closest('#lockScreen')?.querySelector('.btn.btn-primary');
        const runtimeNonce = sessionStorage.getItem('unlockNonce');
        const btnNonce = btn && btn.getAttribute('data-nonce');
        if (!runtimeNonce || !btnNonce || runtimeNonce !== btnNonce) {
            showAlert('Unlock validation failed. Please try again.', 'error');
            return;
        }
    } catch(_) {}
    
    const passwordInput = document.getElementById('lockPassword');
    if (!passwordInput) {
        console.error('Password input not found');
        showAlert('System error: Password field not found', 'error');
        return;
    }
    
    const password = passwordInput.value;
    if (!password) {
        showAlert('Please enter a password', 'warning');
        return;
    }
    
    const savedPassword = localStorage.getItem('sessionLockPassword');
    if (!savedPassword) {
        // Safety: if no password exists, unlock immediately (backup path)
        isSessionLocked = false;
        const lockEl = document.getElementById('lockScreen');
        if (lockEl) lockEl.style.display = 'none';
        document.body.classList.remove('locked');
        try { window.removeEventListener('beforeunload', preventTabClose); } catch (_) {}
        // Remove inert from previously locked UI
        try {
            Array.from(document.body.children).forEach(node => {
                if (node.hasAttribute('inert')) node.removeAttribute('inert');
            });
        } catch(_) {}
        // Persist unlocked state
        try {
            setLockState({ locked: false, timestamp: Date.now(), signature: '' });
        } catch(_) {}
        showAlert('Unlocked (no lock password configured). Set a password to enable locking.', 'info');
        return;
    }
    
    // Simple timing attack protection
    const startTime = performance.now();
    
    // Hash the input password for comparison
    const hashedPassword = btoa(encodeURIComponent(password));
    
    // Use timing-safe comparison
    let isValid = false;
    try {
        // In production, use a proper constant-time comparison
        isValid = hashedPassword === savedPassword;
    } catch (e) {
        console.error('Error comparing passwords:', e);
        showAlert('System error during authentication', 'error');
        return;
    }
    
    // Add artificial delay to prevent timing attacks
    const elapsed = performance.now() - startTime;
    const minDelay = 500; // Minimum 500ms delay
    if (elapsed < minDelay) {
        await new Promise(resolve => setTimeout(resolve, minDelay - elapsed));
    }
    
    if (isValid) {
        isSessionLocked = false;
        document.getElementById('lockScreen').style.display = 'none';
        document.body.classList.remove('locked');
        // Remove beforeunload guard now that we're unlocked
        try { window.removeEventListener('beforeunload', preventTabClose); } catch (_) {}
        // Clear nonce
        try { sessionStorage.removeItem('unlockNonce'); } catch(_) {}
        
        // Re-enable all inputs
        document.querySelectorAll('[data-tabindex]').forEach(el => {
            const tabindex = el.getAttribute('data-tabindex');
            if (tabindex !== '') {
                el.setAttribute('tabindex', tabindex);
            } else {
                el.removeAttribute('tabindex');
            }
            el.removeAttribute('data-tabindex');
        });
        
        // Clear the password field
        document.getElementById('lockPassword').value = '';

        // Persist unlocked state so it doesn't re-lock on refresh
        try {
            const newState = {
                locked: false,
                timestamp: Date.now(),
                signature: ''
            };
            setLockState(newState);
            // Clear lockout on successful unlock
            await clearLockout();
        } catch (e) {
            console.warn('Failed to persist unlock state:', e);
        }
    } else {
        // Wrong password: increment fail count and set escalating backoff
        try {
            const st = await readLockout();
            const nextFail = Number(st.failCount || 0) + 1;
            const delay = backoffDelayMs(nextFail);
            const until = Date.now() + delay;
            await writeLockout({ failCount: nextFail, nextUnlockAt: until });
            showLockoutCountdown(until);
        } catch(_) {}
        showAlert('Incorrect password', 'error');
        document.getElementById('lockPassword').focus();
    }
}

// Check if user is blacklisted
function isBlacklisted() {
    try {
        const blacklistData = localStorage.getItem('sentryBlacklist');
        // If no blacklist exists, return false
        if (!blacklistData) return false;
        
        // Parse the blacklist, defaulting to empty array if invalid
        let blacklist;
        try {
            blacklist = JSON.parse(blacklistData);
        } catch (e) {
            console.error('Error parsing blacklist:', e);
            return false;
        }
        
        // Ensure blacklist is an array
        if (!Array.isArray(blacklist)) {
            console.warn('Blacklist is not an array, resetting to empty array');
            localStorage.setItem('sentryBlacklist', '[]');
            return false;
        }
        
        const ip = localStorage.getItem('lastIP') || '';
        return blacklist.includes(ip);
    } catch (error) {
        console.error('Error in isBlacklisted:', error);
        return false; // Default to not blacklisted if there's an error
    }
}

// Initialize session lock state with integrity check
function initSessionLock() {
    try {
        const lockState = localStorage.getItem('sessionLocked');
        if (!lockState) {
            const newState = {
                locked: false,
                timestamp: Date.now(),
                signature: ''
            };
            setLockState(newState);
            return true;
        }
        return verifyLockState();
    } catch (e) {
        console.error('Error initializing session lock:', e);
        // Reset to default unlocked state on error
        const defaultState = {
            locked: false,
            timestamp: Date.now(),
            signature: ''
        };
        setLockState(defaultState);
        return false;
    }
}

// Set lock state with signature
// Stable signature helper (avoid userAgent variability)
const LOCK_SIGNATURE_SALT = 'SALT_v1';
function computeLockSignature(stateWithoutSig) {
    try {
        const stateString = JSON.stringify(stateWithoutSig);
        return btoa(stateString + LOCK_SIGNATURE_SALT);
    } catch (_) {
        return '';
    }
}

function setLockState(state) {
    // Ensure we compute signature from the object without the signature field
    const clone = { ...state };
    delete clone.signature;
    const signature = computeLockSignature(clone);
    const toStore = { ...clone, signature };
    localStorage.setItem('sessionLocked', JSON.stringify(toStore));
}

// Verify lock state integrity
function verifyLockState() {
    try {
        const lockState = localStorage.getItem('sessionLocked');
        // If no lock state exists, it's valid (first run)
        if (!lockState) return true;
        
        // Parse the state
        let state;
        try {
            state = JSON.parse(lockState);
        } catch (e) {
            console.warn('Failed to parse lock state, resetting:', e);
            return false;
        }
        
        // If it's a new state object without a signature yet, it's valid
        if (!state.signature) return true;
        
        // Verify the signature
        const tempSig = state.signature;
        const clone = { ...state };
        delete clone.signature;
        const expectedSig = computeLockSignature(clone);
        const valid = tempSig === expectedSig;
        if (!valid) {
            // Auto-repair signature silently to avoid noisy false positives
            setLockState(state);
            return true;
        }
        return true;
    } catch (e) {
        console.error('Lock state verification failed:', e);
        // On error, reset to default unlocked state
        const defaultState = {
            locked: false,
            timestamp: Date.now(),
            signature: ''
        };
        setLockState(defaultState);
        return false;
    }
}

// Initialize session lock on page load
document.addEventListener('DOMContentLoaded', function() {
    // SentryLock should not persist across reloads. Use lockSession() for persistent locking instead.

    if (isBlacklisted()) {
        blockAccess('Blacklisted User');
        return;
    }

    initSessionLock();

    // Check if we should show the lock screen
    const lockState = JSON.parse(localStorage.getItem('sessionLocked') || '{}');
    if (lockState.locked) {
        lockSession();
    }
});

// Enhanced security: Prevent context menu and other interactions when locked
function preventContextMenu(e) {
    if (isSessionLocked) {
        // Allow right-click in password field for paste functionality
        if (e.target.id === 'lockPassword') {
            return true;
        }
        
        // Log attempted right-click
        console.warn('Blocked context menu while locked');
        
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
    return true;
}

// Enhanced security: Prevent keyboard shortcuts when locked
function preventShortcuts(e) {
    if (!isSessionLocked) return true;
    
    // Allow only in password field
    if (e.target.id === 'lockPassword') {
        return true;
    }
    
    // Allow some essential browser shortcuts
    const allowedKeys = [
        'F5', 'F12', 'F1',
        'Escape', 'Tab', 'Enter',
        'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'
    ];
    
    const isAllowedKey = allowedKeys.includes(e.key) || 
                        (e.ctrlKey && ['r', 'R', 'f', 'F'].includes(e.key)) ||
                        (e.altKey && e.key === 'Tab');
    
    if (!isAllowedKey) {
        e.preventDefault();
        e.stopPropagation();
        return false;
    }
    
    return true;
}

// Auto Self-Destruct Functions
function openAutoSelfDestruct() {
    const modal = document.getElementById('autoSelfDestructModal');
    const overlay = document.getElementById('autoSelfDestructOverlay');
    const toggle = document.getElementById('autoSelfDestructToggle');
    const timeInputGroup = document.getElementById('timeInputGroup');
    const savedTime = localStorage.getItem('autoSelfDestructTime');
    const isEnabled = localStorage.getItem('autoSelfDestructEnabled') === 'true';

    toggle.checked = isEnabled;
    timeInputGroup.classList.toggle('active', isEnabled);
    
    if (savedTime) {
        document.getElementById('autoSelfDestructTime').value = savedTime;
    }
    
    modal.style.display = 'block';
    overlay.style.display = 'block';
    document.body.style.overflow = 'hidden';
}

function closeAutoSelfDestruct() {
    document.getElementById('autoSelfDestructModal').style.display = 'none';
    document.getElementById('autoSelfDestructOverlay').style.display = 'none';
    document.body.style.overflow = null;
}

function toggleAutoSelfDestruct() {
    const isEnabled = document.getElementById('autoSelfDestructToggle').checked;
    document.getElementById('timeInputGroup').classList.toggle('active', isEnabled);
}

function saveAutoSelfDestruct(event) {
    event.preventDefault();
    const isEnabled = document.getElementById('autoSelfDestructToggle').checked;
    const time = document.getElementById('autoSelfDestructTime').value;

    if (isEnabled && !time) {
        showAlert('Please set a time for auto self-destruct', 'error');
        return;
    }

    localStorage.setItem('autoSelfDestructEnabled', isEnabled);
    if (isEnabled) {
        localStorage.setItem('autoSelfDestructTime', time);
        setAutoSelfDestructTime(); // Set and update UI immediately
        showAlert(`Auto self-destruct enabled at ${time} daily`, 'success');
    } else {
        localStorage.removeItem('autoSelfDestructTime');
        document.getElementById('selfDestructTime').value = ''; // Clear the field
        showAlert('Auto self-destruct disabled', 'success');
    }
    
    closeAutoSelfDestruct();
}

// Function to set auto self-destruct time
function setAutoSelfDestructTime() {
    const isEnabled = localStorage.getItem('autoSelfDestructEnabled') === 'true';
    if (!isEnabled) {
        document.getElementById('selfDestructTime').value = '';
        return;
    }

    const timeStr = localStorage.getItem('autoSelfDestructTime');
    if (!timeStr) return;

    const [hours, minutes] = timeStr.split(':').map(Number);
    const now = new Date();
    const expiry = new Date();
    expiry.setHours(hours, minutes, 0, 0);

    if (expiry < now) {
        expiry.setDate(expiry.getDate() + 1);
    }

    expiry.setMinutes(expiry.getMinutes() - expiry.getTimezoneOffset());
    const formattedDate = expiry.toISOString().slice(0, 16);
    document.getElementById('selfDestructTime').value = formattedDate;
    showAlert(`Auto self-destruct enabled at ${timeStr} daily`, 'success');
}

// Stats Management
const STATS_KEY = 'messageStats';
const ACTIVE_MESSAGES_KEY = 'activeMessages';

// Initialize stats from localStorage or default values
function getStats() {
    const savedStats = localStorage.getItem(STATS_KEY);
    return savedStats ? JSON.parse(savedStats) : {
        encrypted: 0,
        decrypted: 0
    };
}

// Save stats to localStorage
function saveStats(stats) {
    localStorage.setItem(STATS_KEY, JSON.stringify(stats));
}

// Get active messages from localStorage
function getActiveMessages() {
    const saved = localStorage.getItem(ACTIVE_MESSAGES_KEY);
    return saved ? JSON.parse(saved) : [];
}

// Save active messages to localStorage
function saveActiveMessages(messages) {
    localStorage.setItem(ACTIVE_MESSAGES_KEY, JSON.stringify(messages));
}

// Update UI with current stats
function updateStatsUI() {
    const stats = getStats();
    const history = getMessageHistory();
    const now = Date.now();

    history.forEach(msg => {
        if (msg.expiryTime && msg.expiryTime < now && msg.isActive) {
            msg.isActive = false;
        }
    });
    saveMessageHistory(history);

    const activeMessages = history.filter(msg => msg.isActive);
    
    document.getElementById('encryptedCount').textContent = stats.encrypted;
    document.getElementById('decryptedCount').textContent = stats.decrypted;
    document.getElementById('activeCount').textContent = activeMessages.length;
    
    updateHistoryUI();
}

function generateId() {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 9);
    return timestamp + random;
}

// Increment encrypted count and potentially add to active messages
async function recordEncryption(encryptedText, expiryTime = null) {
    const stats = getStats();
    stats.encrypted++;
    saveStats(stats);

    const activeMessages = getActiveMessages();
    activeMessages.push({
        id: generateId(),
        encryptedText,
        expiryTime,
        isActive: true
    });
    saveActiveMessages(activeMessages);
}

// Increment decrypted count and remove from active messages if applicable
function recordDecryption(encryptedText) {
    const stats = getStats();
    stats.decrypted++;
    saveStats(stats);

    // Update active messages by removing any that are expired
    const activeMessages = getActiveMessages();
    const updatedActiveMessages = activeMessages.filter(msg => !msg.expiryTime || msg.expiryTime > Date.now());
    saveActiveMessages(updatedActiveMessages);

    updateStatsUI();
}

// Reset stats (optional, tie to clearAll)
function resetStats() {
    const stats = { encrypted: 0, decrypted: 0 };
    saveStats(stats);
    saveActiveMessages([]);
    updateStatsUI();
}

// function to automatically update the stats UI
document.addEventListener('DOMContentLoaded', function() {
    updateStatsUI();

    // Periodically check active messages for expiry
    setInterval(() => {
        updateStatsUI();
    }, 6000);
});

document.addEventListener('DOMContentLoaded', function() {
    setAutoSelfDestructTime();
});

// =========================
// Settings Enhancements
// =========================

// Apply saved accent color
function applyAccentColor(color) {
    if (!color) return;
    document.documentElement.style.setProperty('--accent-color', color);
}

function setAccentColor(color) {
    try {
        localStorage.setItem('accentColor', color);
        applyAccentColor(color);
        showAlert('Accent color updated.', 'success');
    } catch (e) {
        console.error('setAccentColor error', e);
    }
}

// Compact Mode
function applyCompactMode(enabled) {
    document.documentElement.setAttribute('data-compact', enabled ? 'true' : 'false');
}

function toggleCompactMode() {
    const enabled = document.getElementById('compactModeToggle').checked;
    localStorage.setItem('compactMode', JSON.stringify(enabled));
    applyCompactMode(enabled);
}

// Reduce Motion
function applyReduceMotion(enabled) {
    document.documentElement.setAttribute('data-reduce-motion', enabled ? 'true' : 'false');
}

function toggleReduceMotion() {
    const enabled = document.getElementById('reduceMotionToggle').checked;
    localStorage.setItem('reduceMotion', JSON.stringify(enabled));
    applyReduceMotion(enabled);
}

// Export / Import Settings (preferences only)
function getExportableSettings() {
    const keys = ['theme','requirePassword','autoCopy','accentColor','compactMode','reduceMotion','keyboardShortcuts'];
    const obj = {};
    keys.forEach(k => { const v = localStorage.getItem(k); if (v !== null) obj[k] = v; });
    return obj;
}

function exportSettings() {
    try {
        const data = JSON.stringify(getExportableSettings(), null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'settings.json';
        a.click();
        URL.revokeObjectURL(a.href);
        showAlert('Settings exported.', 'success');
    } catch (e) {
        showAlert('Failed to export settings.', 'error');
    }
}

function handleImportSettings(event) {
    const file = event.target.files && event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
        try {
            const data = JSON.parse(reader.result);
            Object.entries(data).forEach(([k,v]) => localStorage.setItem(k, v));
            // Re-apply
            applyAccentColor(localStorage.getItem('accentColor'));
            applyCompactMode(JSON.parse(localStorage.getItem('compactMode') || 'false'));
            applyReduceMotion(JSON.parse(localStorage.getItem('reduceMotion') || 'false'));
            // Theme
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme) document.documentElement.setAttribute('data-theme', savedTheme);
            // Toggles UI
            const compactToggle = document.getElementById('compactModeToggle');
            if (compactToggle) compactToggle.checked = JSON.parse(localStorage.getItem('compactMode') || 'false');
            const reduceToggle = document.getElementById('reduceMotionToggle');
            if (reduceToggle) reduceToggle.checked = JSON.parse(localStorage.getItem('reduceMotion') || 'false');
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) themeToggle.checked = (savedTheme === 'dark');
            const autoCopyToggle = document.getElementById('autoCopy');
            if (autoCopyToggle) autoCopyToggle.checked = localStorage.getItem('autoCopy') === 'true';
            const picker = document.getElementById('accentColorPicker');
            if (picker && localStorage.getItem('accentColor')) picker.value = localStorage.getItem('accentColor');
            showAlert('Settings imported.', 'success');
        } catch (e) {
            console.error('Import settings error', e);
            showAlert('Invalid settings file.', 'error');
        }
        // reset input so change can trigger again
        event.target.value = '';
    };
    reader.readAsText(file);
}

// Backup message history
function backupHistory() {
    try {
        const history = localStorage.getItem('messageHistory') || '[]';
        const blob = new Blob([history], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'message-history.json';
        a.click();
        URL.revokeObjectURL(a.href);
        showAlert('Message history downloaded.', 'success');
    } catch (e) {
        showAlert('Failed to backup history.', 'error');
    }
}

// Clear non-essential cached data (keeps preferences and history)
function clearCache() {
    const keep = new Set(['theme','requirePassword','autoCopy','accentColor','compactMode','reduceMotion','keyboardShortcuts','messageHistory', STATS_KEY, ACTIVE_MESSAGES_KEY, 'sessionLockPassword']);
    const toRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (!keep.has(k)) toRemove.push(k);
    }
    toRemove.forEach(k => localStorage.removeItem(k));
    showAlert('Cache cleared.', 'success');
}

// Initialize new settings on load
document.addEventListener('DOMContentLoaded', function() {
    try {
        // Accent
        const savedAccent = localStorage.getItem('accentColor');
        if (savedAccent) {
            applyAccentColor(savedAccent);
            const picker = document.getElementById('accentColorPicker');
            if (picker) picker.value = savedAccent;
        }
        // Compact Mode
        const savedCompact = JSON.parse(localStorage.getItem('compactMode') || 'false');
        applyCompactMode(savedCompact);
        const compactToggle = document.getElementById('compactModeToggle');
        if (compactToggle) compactToggle.checked = savedCompact;
        // Reduce Motion
        const savedReduce = JSON.parse(localStorage.getItem('reduceMotion') || 'false');
        applyReduceMotion(savedReduce);
        const reduceToggle = document.getElementById('reduceMotionToggle');
        if (reduceToggle) reduceToggle.checked = savedReduce;
    } catch (e) {
        console.error('Initialize settings error', e);
    }
});
// Default keyboard shortcuts
const defaultShortcuts = {
    encrypt: 'Ctrl+E',
    decrypt: 'Ctrl+D',
    copy: 'Ctrl+C',
    lock: 'Ctrl+L',
    save: 'Ctrl+S'
};

// Load saved shortcuts or use defaults
function loadShortcuts() {
    const savedShortcuts = JSON.parse(localStorage.getItem('keyboardShortcuts')) || {};
    return { ...defaultShortcuts, ...savedShortcuts };
}

// Current shortcuts
let shortcuts = loadShortcuts();

// Handle keyboard events
document.addEventListener('keydown', (event) => {
    if (isSessionLocked) {
        // Only allow input in the lock password field when locked
        if (event.target.id !== 'lockPassword') {
            event.preventDefault();
            document.getElementById('lockPassword').focus();
        }
        return;
    }

    if (!shortcutsEnabled) return;
    
    const isCtrl = event.ctrlKey || event.metaKey;
    const key = event.key.toUpperCase();

    // Check for shortcut combinations
    const shortcutPressed = Object.entries(shortcuts).find(([action, shortcut]) => {
        const keys = shortcut.split('+');
        return keys.every(k => {
            if (k === 'Ctrl') return isCtrl;
            if (k === 'Shift') return event.shiftKey;
            if (k === 'Alt') return event.altKey;
            return k.toUpperCase() === key;
        });
    });

    if (shortcutPressed) {
        const [action] = shortcutPressed;
        event.preventDefault();
        
        switch(action) {
            case 'encrypt':
                document.getElementById('encryptBtn').click();
                break;
            case 'decrypt':
                document.getElementById('decryptBtn').click();
                break;
            case 'copy':
                document.execCommand('copy');
                break;
            case 'lock':
                lockSession();
                break;
            case 'save':
                downloadResult();
                break;
        }
    }
});

// Save shortcuts to localStorage
function saveShortcuts(newShortcuts) {
    shortcuts = { ...defaultShortcuts, ...newShortcuts };
    localStorage.setItem('keyboardShortcuts', JSON.stringify(shortcuts));
}

// Toggle shortcuts enable/disable (to be used in settings)
function toggleShortcuts(enabled) {
    shortcutsEnabled = enabled;
    localStorage.setItem('shortcutsEnabled', enabled);
}

// Load shortcuts enabled state
document.addEventListener('DOMContentLoaded', () => {
    const savedEnabled = localStorage.getItem('shortcutsEnabled');
    shortcutsEnabled = savedEnabled !== null ? JSON.parse(savedEnabled) : true;
});

function openShortcutSettings() {
    const modal = document.getElementById('shortcutModal');
    const overlay = document.getElementById('shortcutOverlay');
    const settingsDiv = document.getElementById('shortcutSettings');

    // Clear previous content
    settingsDiv.innerHTML = '';

    // Populate with current shortcuts
    Object.entries(shortcuts).forEach(([action, shortcut]) => {
        const label = action.charAt(0).toUpperCase() + action.slice(1);
        settingsDiv.innerHTML += `
            <div class="form-group">
                <label>${label}</label>
                <input type="text" class="shortcut-input" data-action="${action}" value="${shortcut}" placeholder="e.g., Ctrl+E">
            </div>
        `;
    });

    modal.style.display = 'block';
    overlay.style.display = 'block';
    document.body.style.overflow = 'hidden';
}

function closeShortcutSettings() {
    document.getElementById('shortcutModal').style.display = 'none';
    document.getElementById('shortcutOverlay').style.display = 'none';
    document.body.style.overflow = null;
}

function SentryLock(isWhitelistMissing = false, missingFile = null) {
    // Check if already locked to prevent multiple calls
    if (document.getElementById('special-access-denied').style.display === 'block') {
        return;
    }

    const blockSpecialAccess = document.getElementById('special-access-denied');
    // Do not persist SentryLock across refreshes. Session locking uses lockSession().

    // Add CSS to center the overlay
    blockSpecialAccess.style.position = 'fixed';
    blockSpecialAccess.style.top = '50%';
    blockSpecialAccess.style.left = '50%';
    blockSpecialAccess.style.transform = 'translate(-50%, -50%)';
    blockSpecialAccess.style.width = '100%';
    blockSpecialAccess.style.height = '100%';
    blockSpecialAccess.style.zIndex = '9999';

    const now = new Date();
    const requiredFiles = ['Whitelist.js', 'BugReport.js', 'Decrypt.js', 'Encrypt.js', 'messageHistory.js', 'MessageService.js'];
    
    if (missingFile) {
        blockSpecialAccess.innerHTML = `
            <div class="blocked-overlay">
                <div class="blocked-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                    <h2 style="font-size: 1.8rem; margin-bottom: 1rem;">SentryLock Security Error</h2>
                    <p style="margin-top: 1.5rem;">The required file "${missingFile}" is missing at</p>
                    <p style="margin-top: -1rem; color: white;"><strong>${now.toLocaleTimeString()} on ${now.toLocaleDateString()}</strong>.</p>
                    <p style="margin-top: 1rem;">This file is required for the tool to function properly.</p>
                    <p>Required files:</p>
                    <ul style="color: white; margin: 1rem 0;">
                        ${requiredFiles.map(file => `<li>${file} ${file === missingFile ? '⚠️' : '✓'}</li>`).join('')}
                    </ul>
                    <p>Please ensure all required files are in the same directory as the HTML file.</p>
                    <p>If you need help, contact:</p>
                    <p style="color: white;"><strong>mcgahaj2@students.hcboe.net</strong></p>
                    <div class="blocked-warning" style="margin-top: 2rem; text-align: center;">
                        <span style="font-size: 1.3rem; animation: pulse 5s infinite; text-align: center; display: block;">
                            <strong>Error Code: MISSING_${missingFile.replace(/\s+/g, '_').toUpperCase().replace('.JS','')}</strong>
                        </span>
                    </div>
                </div>
            </div>
        `;
    } else {
        blockSpecialAccess.innerHTML = `
            <div class="blocked-overlay">
                <div class="blocked-content" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
                    <h2 style="font-size: 1.8rem; margin-bottom: 1rem;">SentryLock Security Error</h2>
                    <p style="margin-top: 1.5rem;">There was an error fetching the security configuration at</p>
                    <p style="margin-top: -1rem; color: white;"><strong>${now.toLocaleTimeString()} on ${now.toLocaleDateString()}</strong>.</p>
                    <p style="margin-top: 1rem;">As a safety precaution, access to the tool is blocked.</p> 
                    <p>If you're getting this error, please message me at</p>
                    <p style="color: white;"><strong>mcgahaj2@students.hcboe.net</strong></p> 
                    <p>with a copy of your HTML file and what's going on so I can help resolve the issue.</p>
                    <div class="blocked-warning" style="margin-top: 2rem; text-align: center;">
                        <span style="font-size: 1.3rem; animation: pulse 5s infinite; text-align: center; display: block;">
                            <strong>This incident has <strong>NOT</strong> been logged.</strong>
                        </span>
                    </div>
                </div>
            </div>
        `;
    }
            
    blockSpecialAccess.style.display = 'block';
    document.querySelector('.container').style.display = 'none';
    document.body.style.overflow = 'hidden';
}

// Utility to clear persisted SentryLock state and hide overlay
function clearSentryLock() {
    try {
        // Require the session lock password to proceed
        const savedPassword = localStorage.getItem('sessionLockPassword');
        if (!savedPassword) {
            showAlert('Security action blocked: no lock password set.', 'error');
            return;
        }
        const input = prompt('Enter session lock password to clear security lock:');
        if (input == null) return; // cancelled
        const hashed = btoa(encodeURIComponent(input));
        if (hashed !== savedPassword) {
            showAlert('Unauthorized: incorrect password.', 'error');
            return;
        }

        // Clear persisted SentryLock flags only (do not alter session lock)
        localStorage.removeItem('sentryLockActive');
        localStorage.removeItem('sentryLockReason');
        localStorage.removeItem('sentryLockMissingFile');
        localStorage.removeItem('sentryLockTimestamp');

        const special = document.getElementById('special-access-denied');
        if (special) special.style.display = 'none';
        const container = document.querySelector('.container');
        if (container) container.style.display = 'block';
        document.body.style.overflow = null;
        showAlert('Security overlay cleared.', 'success');
    } catch (e) {
        console.error('Failed to clear SentryLock:', e);
        showAlert('Failed to clear SentryLock. See console for details.', 'error');
    }
}

// Save shortcut settings
function saveShortcutSettings(event) {
    event.preventDefault();
    const inputs = document.querySelectorAll('.shortcut-input');
    const newShortcuts = {};

    inputs.forEach(input => {
        const action = input.getAttribute('data-action');
        const value = input.value.trim();
        if (value) newShortcuts[action] = value;
    });

    saveShortcuts(newShortcuts);
    showAlert('Keyboard shortcuts updated!', 'success');
    closeShortcutSettings();
}

// Reset to default shortcuts
function resetShortcuts() {
    localStorage.removeItem('keyboardShortcuts');
    shortcuts = loadShortcuts();
    showAlert('Shortcuts reset to default!', 'success');
    openShortcutSettings(); // Refresh the modal with defaults
}

document.addEventListener('DOMContentLoaded', function() {
    const scripts = document.getElementsByTagName('script');
    const requiredFiles = ['Whitelist.js', 'BugReport.js', 'Decrypt.js', 'Encrypt.js', 'messageHistory.js', 'MessageService.js'];
    const missingFiles = [...requiredFiles];

    for (let script of scripts) {
        if (script.src) {
            for (const file of requiredFiles) {
                if (script.src.includes(file)) {
                    const index = missingFiles.indexOf(file);
                    if (index > -1) {
                        missingFiles.splice(index, 1);
                    }
                }
            }
        }
    }

    if (missingFiles.length > 0) {
        SentryLock(true, missingFiles[0]);
    }
});

window.addEventListener('error', function(event) {
    const requiredFiles = ['Whitelist.js', 'BugReport.js', 'Decrypt.js', 'Encrypt.js', 'messageHistory.js', 'MessageService.js'];
    for (const file of requiredFiles) {
        if (event.target.src && event.target.src.includes(file)) {
            SentryLock(true, file);
            event.preventDefault();
            return;
        }
    }
}, true);


// Toggle quick-set options visibility
document.querySelector('.toggle-quick-set').addEventListener('click', function() {
    const options = document.getElementById('quickSetOptions');
    const isExpanded = this.getAttribute('aria-expanded') === 'true';
    this.setAttribute('aria-expanded', !isExpanded);
    options.hidden = isExpanded;
});

// Event delegation for quick-set buttons
document.getElementById('quickSetOptions').addEventListener('click', function(e) {
    const button = e.target.closest('.quick-set');
    if (!button) return;

    if (button.dataset.minutes) {
        setFutureTime(parseInt(button.dataset.minutes));
    } else if (button.dataset.today) {
        setToday3PM();
    }
});

// Ensure datetime input has a minimum of now (sam if you read this, this is already in the code, i'm just confirming placement)
document.addEventListener('DOMContentLoaded', function() {
    const selfDestructInput = document.getElementById('selfDestructTime');
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    selfDestructInput.min = now.toISOString().slice(0, 16);
});

// Check if SentryLock exists, if not, lock access as a precaution
if (typeof SentryLock !== 'function') {
    document.getElementById('special-access-denied').innerHTML = `
        <div class="blocked-overlay">
            <div class="blocked-content">
                <h2 style="font-size: 1.8rem; margin-bottom: 1rem;">SentryLock Security Error</h2>
                <p style="margin-top: 1.5rem;">The required SentryLock function is missing.</p>
                <p style="margin-top: 1rem;">This function is required for the tool to function properly.</p>
                <p>If you need help, contact:</p>
                <p style="color: white;"><strong>mcgahaj2@students.hcboe.net</strong></p>
                <div class="blocked-warning" style="margin-top: 2rem; text-align: center;">
                    <span style="font-size: 1.3rem; animation: pulse 5s infinite; text-align: center; display: block;">
                        <strong>Error Code: MISSING_SENTRYLOCK</strong>
                    </span>
                </div>
            </div>
        </div>
    `;
    document.getElementById('special-access-denied').style.display = 'block';
    document.querySelector('.container').style.display = 'none';
    document.body.style.overflow = 'hidden';
}

// Initialize settings tabs functionality
function initSettingsTabs() {
    const tabs = document.querySelectorAll('.settings-tab');
    const tabPanels = document.querySelectorAll('.settings-section');

    // Function to switch tabs
    function switchTab(tabId) {
        // Hide all tab panels (use both hidden and display to avoid CSS timing issues)
        tabPanels.forEach(panel => {
            panel.hidden = true;
            panel.setAttribute('aria-hidden', 'true');
            panel.style.display = 'none';
        });

        // Deactivate all tabs
        tabs.forEach(tab => {
            tab.setAttribute('aria-selected', 'false');
            tab.classList.remove('active');
        });

        // Show the selected tab panel
        const selectedPanel = document.getElementById(`tab-${tabId}`);
        if (selectedPanel) {
            selectedPanel.hidden = false;
            selectedPanel.setAttribute('aria-hidden', 'false');
            selectedPanel.style.display = 'block';
        }

        // Activate the selected tab
        const selectedTab = document.querySelector(`[data-tab="${tabId}"]`);
        if (selectedTab) {
            selectedTab.setAttribute('aria-selected', 'true');
            selectedTab.classList.add('active');
            selectedTab.focus();
        }

        // Reapply current search filter for the newly selected panel
        const searchInput = document.getElementById('settingsSearchInput');
        const q = (searchInput && searchInput.value) ? String(searchInput.value).trim() : '';
        if (q) {
            filterSettings(q);
        } else {
            // Ensure all items in this panel are visible when no filter
            if (selectedPanel) {
                selectedPanel.querySelectorAll('.setting-item').forEach(it => { it.style.display = 'flex'; });
            }
        }
    }

    // Add click event listeners to tabs
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            const tabId = tab.getAttribute('data-tab');
            if (tabId) {
                switchTab(tabId);
                // Save the active tab to localStorage
                localStorage.setItem('lastActiveTab', tabId);
            }
        });

        // Add keyboard navigation
        tab.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                tab.click();
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                e.preventDefault();
                const currentIndex = Array.from(tabs).indexOf(tab);
                let nextIndex;
                
                if (e.key === 'ArrowRight') {
                    nextIndex = (currentIndex + 1) % tabs.length;
                } else {
                    nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                }
                
                tabs[nextIndex].focus();
            }
        });
    });

    // Load the last active tab or default to 'general'
    const lastActiveTab = localStorage.getItem('lastActiveTab') || 'general';
    switchTab(lastActiveTab);
}

// Fix slider positioning
function fixSliders() {
    const sliders = document.querySelectorAll('.setting-toggle');
    sliders.forEach(slider => {
        const container = slider.closest('.setting-item');
        if (container) {
            container.style.position = 'relative';
            slider.style.position = 'absolute';
            slider.style.right = '0';
            slider.style.top = '50%';
            slider.style.transform = 'translateY(-50%)';
        }
    });
}

// Initialize on DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
    initSettingsTabs();
    fixSliders();
});
 

    </script>
</body>
</html>